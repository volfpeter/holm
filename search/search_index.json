{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"holm","text":"<p>Web development framework that brings the Next.js developer experience to Python, built on FastAPI, <code>htmy</code>, and FastHX.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Next.js-like developer experience with file-system based routing and page composition.</li> <li>Standard FastAPI everywhere, so you can leverage the entire FastAPI ecosystem.</li> <li>JSX-like syntax with async support for components, thanks to <code>htmy</code>.</li> <li>First class HTMX support with <code>FastHX</code>.</li> <li>Async support everywhere, from APIs and dependencies all the way to UI components.</li> <li>Support for both JSON and HTML (server side rendering) APIs.</li> <li>No JavaScript dependencies</li> <li>No build steps, just server side rendering with fully typed Python.</li> <li>Stability by building only on the core feature set of dependent libraries.</li> <li>Unopinionated: use any CSS framework for styling and any JavaScript framework for UI interactivity.</li> </ul>"},{"location":"#pre-requisite-knowledge","title":"Pre-requisite knowledge","text":"<p>Don't be intimidated by this section. By the time you go through the Application components document and the Quick start guide, you will have a very good intuition of how to use <code>holm</code>.</p> <p>To get started, all you need is a basic understanding of:</p> <ul> <li>FastAPI: the underlying web framework.</li> <li>htmy: the used component / templating and rendering library.</li> <li>HTML and CSS fundamentals.</li> </ul> <p>Familiarity with FastHX (the rendering layer between <code>htmy</code> and <code>FastAPI</code>), and especially its <code>htmy</code> integration is useful, but not necessary, unless you are building an HTMX application.</p> <p>It is recommended to use HTMX, if for nothing else, then to avoid hard page loads on navigation. hx-boost (or navigation with <code>hx-get</code>) offers the same benefits as the <code>Link</code> component in Next.js.</p>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI and can be installed with:</p> <pre><code>pip install holm\n</code></pre> <p>Supported operating systems:</p> <ul> <li>Linux</li> <li>macOS</li> <li>Windows: WSL only (native support may arrive in the future)</li> </ul>"},{"location":"#support","title":"Support","text":"<p>Consider supporting the development and maintenance of the project through sponsoring, or reach out for consulting so you can get the most out of the library.</p>"},{"location":"#application-structure","title":"Application structure","text":"<p>Similarly to Next.js, <code>holm</code> is built around the concept of file-system based routing. This essentially means that your code structure is automatically mapped to a matching API:</p> <ul> <li>You do not need to manually define routes, every application component is automatically discovered and registered in the application.</li> <li>You do not need to manually wrap pages in their layouts, it is automatically done based on your application's code structure.</li> </ul> <p>You can find all the necessary details on the Application components page, and the Quick start guide can walk you through the process of creating your first application. The two are complementary documents, reading both is strongly recommended.</p> <p>HTML rendering is also fully automated, in the vast majority of cases you do not need to concern yourself with that (the only exceptions are HTML APIs, more on that in the Rendering APIs with HTMX guide).</p> <p>All you need to do is follow these simple rules:</p> <ul> <li>You must initialize your application instance using <code>holm.App()</code>. It optionally accepts a base <code>FastAPI</code> application and a <code>fasthx.htmy.HTMY</code> instance that handles HTML rendering.</li> <li><code>holm.App()</code> must be called directly within a module in your root application package to make automatic application discovery work.</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>If you prefer to learn through examples, the Quick start guide is the best place to start.</p> <p>To learn about creating rendering APIs and adding HTMX to your application, you should have a look at the Rendering APIs with HTMX guide.</p> <p>The Custom applications guide shows you how to customize the FastAPI application instance as well as HTML rendering.</p> <p>For error handling examples, you should check out the Error Handling guide.</p> <p>You can discover even more features by exploring the test application of the project.</p> <p>If you are looking for the simplest possible application you can create, then can find it in the examples/minimal directory of the repository.</p>"},{"location":"#security","title":"Security","text":"<p>At the moment, the library does not provide security features like automatic CSRF prevention out of the box. A custom form component and a corresponding middleware may be added to the library later, but of course 3rd party implementations are very welcome! Alternative solutions include JavaScript, but the library aims to remain unopinionated, especially on the client front. If you use HTMX, you should check out their CSRF prevention recommendation, just keep in mind that the <code>&lt;body&gt;</code> tag is not swapped for boosted requests.</p> <p>Also, do not forget about XSS prevention, when rendering untrusted data with custom components!</p>"},{"location":"#ai-assistance","title":"AI assistance","text":"<p>The library and all its dependencies are registered at Context7.</p> <p>To get good AI assistance, all you need to do is register the Context7 MCP server in your coding tool and tell the agent to use it.</p> <p>If you are starting a new project, you can additionally point the agent at one of the example applications in the repository. With all this context and detailed instructions of the project you want to build, it will get you started quickly.</p> <p>Because of the similarity with Next.js and React, and the standard use of FastAPI and other dependencies, you can expect good results, both for vibe coding or inline completion.</p>"},{"location":"#technical-notes","title":"Technical notes","text":""},{"location":"#performance","title":"Performance","text":"<p>Automatic application discovery and route registration takes only marginally more time compared to manual route registration. The performance difference during startup is unnoticeable.</p> <p>When it comes to serving requests, there are two cases: standard JSON APIs and web applications.</p> <p>For JSON APIs, the performance overhead is zero. In this case you are only using the application discovery feature of <code>holm</code>.</p> <p>When building web applications, performance should be compared to an application that does all the rendering manually in routes, using <code>htmy</code>. In this case, a <code>holm</code> application will typically need to resolve a couple of additional dependencies, but because of the efficiency of FastAPI's dependency resolution mechanism, the performance impact is still unnoticeable.</p>"},{"location":"#templating-language-support","title":"Templating language support","text":"<p>While certain features in <code>holm</code> rely heavily on the capabilities of <code>htmy</code> (for example its context and async support), you can still use other DSLs or templating languages (for example Jinja) in your application if you would like to. All you need to do is write a simple wrapper <code>htmy</code> component that internally offloads rendering to your framework of choice. You can find out more about this in the htmy documentation.</p>"},{"location":"#development","title":"Development","text":"<p>Development setup:</p> <ul> <li><code>uv</code> for project and dependency management.</li> <li><code>poethepoet</code> for running tasks. Run <code>uv run poe</code> to see all available tasks.</li> <li><code>mypy</code> for static code analysis.</li> <li><code>ruff</code> is used for formatting and linting.</li> <li><code>pytest</code> for testing.</li> <li><code>mkdocs-material</code> and <code>mkdocstrings</code> for documentation.</li> </ul> <p>Tests are located in the <code>tests</code> directory and they use the application defined in the <code>test_app</code> package (through a <code>TestClient</code>). This setup makes it possible to run <code>test_app</code> outside of tests, which is useful for debugging.</p> <p>You can run all tests with <code>uv run poe test</code>. You can separately start the test application with <code>uv run poe test-app</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community to help improve the project! Whether you're an experienced developer or just starting out, there are many ways you can contribute:</p> <ul> <li>Discuss: Join our Discussion Board to ask questions, share ideas, provide feedback, and engage with the community.</li> <li>Document: Help improve the documentation by fixing typos, adding examples, and updating guides to make it easier for others to use the project.</li> <li>Develop: Prototype requested features or pick up issues from the issue tracker.</li> <li>Test: Write tests to improve coverage and reliability.</li> </ul>"},{"location":"#comparison-with-other-frameworks","title":"Comparison with other frameworks","text":""},{"location":"#frameworks-with-javascript-dependencies","title":"Frameworks with JavaScript dependencies","text":"<p>The most prominent frameworks in this category are Reflex and NiceGUI. They both provide a Python-first web development experience while using complex JavaScript frameworks under the hood for constructing user interfaces (namely React and Vue.js). They take care of state management and synchronization (using WebSockets), seamlessly connecting the JavaScript frontend and the Python backend. In exchange for this convenience comes complexity and heavy reliance on the ever-changing JavaScript ecosystem.</p> <p><code>holm</code> comes with no JavaScript dependencies, but that doesn't mean you can't use JavaScript to add frontend interactivity. In fact, it comes with first class HTMX support and naturally works with frameworks like Alpine.js. Web component frameworks like lit, and even React application segments can also be integrated, just like into any server rendered page.</p>"},{"location":"#pure-server-side-rendering-frameworks","title":"Pure server-side rendering frameworks","text":"<p>This category includes frameworks like FastHTML or Ludic, and this is where <code>holm</code> belongs as well, but it has some key differentiators.</p> <p>First, <code>holm</code> brings the Next.js developer experience to Python with file-system based routing, automatic layout composition, and dynamic page metadata creation, and more. Thanks to <code>htmy</code>, it supports async code throughout the stack, even in components, and it also solves the prop drilling problem. While being built with <code>htmy</code>, it is easy to integrate with other templating libraries, like <code>Jinja</code> or <code>htpy</code>. And it provides all these features using standard, simple FastAPI patterns.</p>"},{"location":"#license","title":"License","text":"<p>The package is open-sourced under the conditions of the MIT license.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#holm.App","title":"<code>holm.App(*, app=None, htmy=None)</code>","text":"<p>Creates a FastAPI application with all the routes that are defined in the application package.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI | None</code> <p>Optional FastAPI application to use. If <code>None</code>, a new instance will be created.</p> <code>None</code> <code>htmy</code> <code>HTMY | None</code> <p>Optional <code>fasthx.htmy.HTMY</code> instance to use for server-side rendering. If <code>None</code>, a default instance will be created.</p> <code>None</code> Source code in <code>holm/app.py</code> <pre><code>def App(*, app: FastAPI | None = None, htmy: HTMY | None = None) -&gt; FastAPI:\n    \"\"\"\n    Creates a FastAPI application with all the routes that are defined in the application package.\n\n    Arguments:\n        app: Optional FastAPI application to use. If `None`, a new instance will be created.\n        htmy: Optional `fasthx.htmy.HTMY` instance to use for server-side rendering. If `None`,\n            a default instance will be created.\n    \"\"\"\n    if app is None:\n        app = FastAPI()\n\n    if htmy is None:\n        htmy = HTMY()\n\n    config = AppConfig.default()\n    packages = _discover_app_packages(config)\n    root_node = _build_app_tree(packages)\n\n    # Register error handlers\n    if pkg := root_node.package:\n        register_error_handlers(app, pkg.import_module(\"error\", is_error_handler_owner), htmy=htmy)\n\n    # Build the API\n    app.include_router(_build_api(root_node, htmy=htmy))\n\n    return app\n</code></pre>"},{"location":"api/#holm.Metadata","title":"<code>holm.Metadata</code>","text":"<p>               Bases: <code>ContextAware</code></p> <p>Context-aware metadata provider.</p> <p>The class implements the <code>Mapping</code> protocol as a means of giving convenient access to the metadata it contains.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>class Metadata(ContextAware):\n    \"\"\"\n    Context-aware metadata provider.\n\n    The class implements the `Mapping` protocol as a means of giving convenient access to\n    the metadata it contains.\n    \"\"\"\n\n    __slots__ = (\"_metadata\",)\n\n    def __init__(self, metadata: MetadataMapping | None = None) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            metadata: The actual metadata mapping.\n        \"\"\"\n        self._metadata = {} if metadata is None else metadata\n        \"\"\"The metadata mapping.\"\"\"\n\n    @overload\n    def get(self, key: Any, default: None = None) -&gt; Any | None: ...\n\n    @overload\n    def get(self, key: Any, default: Any) -&gt; Any: ...\n\n    def get(self, key: Any, default: Any | None = None) -&gt; Any | None:\n        \"\"\"Implements `Mapping.get()`.\"\"\"\n        return self._metadata.get(key, default)\n\n    def __contains__(self, key: Any) -&gt; bool:\n        \"\"\"Implements the `Container` protocol.\"\"\"\n        return key in self._metadata\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, Metadata) and self._metadata == other._metadata\n\n    def __getitem__(self, key: Any) -&gt; Any:\n        \"\"\"Implements the `Sequence` protocol.\"\"\"\n        return self._metadata[key]\n\n    def __iter__(self) -&gt; Iterator[Any]:\n        \"\"\"Implements the `Iterable` protocol.\"\"\"\n        return iter(self._metadata)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Implements the `Sized` protocol.\"\"\"\n        return len(self._metadata)\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self.__eq__(other)\n\n    def items(self) -&gt; ItemsView[Any, Any]:\n        \"\"\"Implements `Mapping.items()`.\"\"\"\n        return self._metadata.items()\n\n    def keys(self) -&gt; KeysView[Any]:\n        \"\"\"Implements `Mapping.keys()`.\"\"\"\n        return self._metadata.keys()\n\n    def values(self) -&gt; ValuesView[Any]:\n        \"\"\"Implements `Mapping.values()`.\"\"\"\n        return self._metadata.values()\n</code></pre>"},{"location":"api/#holm.Metadata.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Implements the <code>Container</code> protocol.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def __contains__(self, key: Any) -&gt; bool:\n    \"\"\"Implements the `Container` protocol.\"\"\"\n    return key in self._metadata\n</code></pre>"},{"location":"api/#holm.Metadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Implements the <code>Sequence</code> protocol.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def __getitem__(self, key: Any) -&gt; Any:\n    \"\"\"Implements the `Sequence` protocol.\"\"\"\n    return self._metadata[key]\n</code></pre>"},{"location":"api/#holm.Metadata.__iter__","title":"<code>__iter__()</code>","text":"<p>Implements the <code>Iterable</code> protocol.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Any]:\n    \"\"\"Implements the `Iterable` protocol.\"\"\"\n    return iter(self._metadata)\n</code></pre>"},{"location":"api/#holm.Metadata.__len__","title":"<code>__len__()</code>","text":"<p>Implements the <code>Sized</code> protocol.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Implements the `Sized` protocol.\"\"\"\n    return len(self._metadata)\n</code></pre>"},{"location":"api/#holm.Metadata.get","title":"<code>get(key, default=None)</code>","text":"<pre><code>get(key: Any, default: None = None) -&gt; Any | None\n</code></pre><pre><code>get(key: Any, default: Any) -&gt; Any\n</code></pre> <p>Implements <code>Mapping.get()</code>.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def get(self, key: Any, default: Any | None = None) -&gt; Any | None:\n    \"\"\"Implements `Mapping.get()`.\"\"\"\n    return self._metadata.get(key, default)\n</code></pre>"},{"location":"api/#holm.Metadata.items","title":"<code>items()</code>","text":"<p>Implements <code>Mapping.items()</code>.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def items(self) -&gt; ItemsView[Any, Any]:\n    \"\"\"Implements `Mapping.items()`.\"\"\"\n    return self._metadata.items()\n</code></pre>"},{"location":"api/#holm.Metadata.keys","title":"<code>keys()</code>","text":"<p>Implements <code>Mapping.keys()</code>.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def keys(self) -&gt; KeysView[Any]:\n    \"\"\"Implements `Mapping.keys()`.\"\"\"\n    return self._metadata.keys()\n</code></pre>"},{"location":"api/#holm.Metadata.values","title":"<code>values()</code>","text":"<p>Implements <code>Mapping.values()</code>.</p> Source code in <code>holm/modules/_metadata.py</code> <pre><code>def values(self) -&gt; ValuesView[Any]:\n    \"\"\"Implements `Mapping.values()`.\"\"\"\n    return self._metadata.values()\n</code></pre>"},{"location":"application-components/","title":"Application components","text":"<p>This section summarizes the different components of <code>holm</code> applications. If you have used Next.js before, you will find these concepts very familiar. If not, don't worry, they may seem complex at first, but they are quite intuitive and natural.</p>"},{"location":"application-components/#layouts-and-pages","title":"Layouts and pages","text":"<p>Layouts are defined in the <code>layout.py</code> modules of packages as a callable <code>layout</code> variable (note that for example classes with an <code>__init__()</code> method, or <code>htmy.Component</code>s are callable, so they also qualify).</p> <p>Rules for layouts:</p> <ul> <li>The root layout must always return a <code>htmy.Component</code>.</li> <li>The <code>layout</code> variable must be a callable and it must accept a positional argument (other than <code>self</code> if the layout is a method of a class), the data / properties of the layout that are returned by the pages or layouts this layout directly wraps.</li> <li>The <code>layout</code> variable can have additional arguments (position or keyword and keyword-only, but not positional-only). These arguments must be FastAPI dependencies. They will be automatically resolved during each request.</li> <li>Returning a tuple or a list from a layout is not allowed unless the value is a <code>htmy.ComponentSequence</code>. Tuples and lists are always interpreted and treated as component sequences, so you don't need to track what kinds of components pages and layouts return. See <code>htmy.is_component_sequence()</code> for more information.</li> </ul> <p>Layouts automatically wrap all layouts and pages in subpackages.</p> <p>Tip: layouts can provide context for their entire subtree by wrapping the subtree with a <code>htmy</code> <code>ContextProvider</code> component.</p> <p>Pages are defined in the <code>page.py</code> module of packages as a callable <code>page</code> variable (note that classes with an <code>__init__()</code> method are callable, so they also qualify).</p> <p>Rules for pages:</p> <ul> <li>The <code>page</code> variable must be a FastAPI dependency, meaning it can have any arguments as long as they can all be resolved by FastAPI as dependencies.</li> <li>The <code>page</code> variable must return the properties object for the layout that directly wraps it.</li> <li>If a page is not wrapped by a layout, then it must return a <code>htmy.Component</code>.</li> <li>Returning a tuple or a list from a page is not allowed unless the value is a <code>htmy.ComponentSequence</code>. Tuples and lists are always interpreted and treated as component sequences, so you don't need to track what kinds of components pages and layouts return. See <code>htmy.is_component_sequence()</code> for more information.</li> </ul> <p><code>page.py</code> modules can have a <code>metadata</code> variable, which can be an arbitrary mapping or a FastAPI dependency that returns an arbitrary mapping.</p> <p>If the <code>metadata</code> variable is a callable, it can have any FastAPI dependencies, even different ones than what the <code>page</code> or wrapper layouts use.</p> <p>The metadata provided by the currently served page is made available to every <code>htmy.Component</code> (from the root layout to the page itself) through the built-in <code>Metadata</code> utility. It can be accessed as <code>Metadata.from_context(context)</code> where <code>context</code> is the <code>htmy</code> rendering context which is passed to every component. See the htmy documentation for more information.</p> <p>This feature is particularly useful when page-specific information - for example title, description, or keywords - must be set dynamically (for example, in layouts) on a page-by-page basis. <code>Metadata</code> implements the <code>Mapping</code> protocol, so once loaded from the <code>htmy</code> rendering context in a component with <code>metadata = Metadata.from_context(context)</code>, you can use it simply like this to set page-specific information in any layout, component, or the page itself: <code>htmy.html.title(metadata[\"title\"])</code>.</p>"},{"location":"application-components/#apis","title":"APIs","text":"<p>APIs are defined in the <code>api.py</code> module or packages as an <code>APIRouter</code> variable or a callable that returns an <code>APIRouter</code>.</p> <p>These are standard FastAPI <code>APIRouter</code>s, but you should still follow these recommendations:</p> <ul> <li>If routes in the API don't do any rendering, then the <code>api()</code> callable should have no arguments or simply an <code>api</code> variable should be used. Otherwise the <code>api()</code> callable should have a single <code>fasthx.htmy.HTMY</code> positional argument. The application's renderer will be passed to this function automatically by <code>holm</code>.</li> <li>If an <code>api()</code> callable is used, it may have further arguments as long as they all have default values. This pattern can simplify API testing for example, by allowing custom configurations for tests.</li> </ul> <p>Note on rendering APIs:</p> <ul> <li>The primary role of these APIs is to return so called \"partials\" (small HTML snippets instead of entire HTML pages) to clients such as HTMX for swapping.</li> <li>The components returned by rendering routes are not automatically wrapped in layouts like pages are.</li> </ul>"},{"location":"application-components/#path-parameters-as-package-names","title":"Path parameters as package names","text":"<p>Routes with path parameters, also often referred to as \"dynamic routes\", are essential to almost all applications. A simple example is a user profile page, served at <code>/user/{id}</code> for example, where we want to display information about the user with the given ID.</p> <p>You can capture dynamic URL path parameters by using special package names. Two formats are supported:</p> <ul> <li><code>_param_</code> format: package names like <code>_id_</code> or <code>_user_id_</code>.</li> <li><code>{param}</code> format: package names like <code>{id}</code> or <code>{user_id}</code>. (Note: it works with <code>holm</code>, but static code analysis tools flag it because <code>{id}</code> is not a valid Python identifier.)</li> </ul> <p>Both formats are converted to FastAPI path parameters. For example:</p> <ul> <li>File path <code>user/_id_/page.py</code> becomes URL <code>/user/{id}</code>.</li> <li>File path <code>user/{user_id}/settings/page.py</code> becomes URL <code>/user/{user_id}/settings</code>.</li> </ul> <p>Any layout or page within these packages can access the path parameter as a FastAPI dependency by adding it to their function signature (e.g., <code>id: int</code> or <code>user_id: str</code>).</p>"},{"location":"application-components/#private-packages","title":"Private packages","text":"<p>You can prefix package names with one or more underscores to opt the entire package (including its subpackages) out of the automatic application component discovery.</p> <p>For example, if you have a package named <code>_private</code> somewhere in your application folder, you can freely place valid page, layout, or API files within it or its subpackages. These modules will not be processed and included in the application.</p> <p>Reminder: if the package name also ends with an underscore, it will be treated as a path parameter, as described above.</p>"},{"location":"application-components/#error-handling","title":"Error handling","text":"<p>Error handlers are defined in the <code>error.py</code> module of the root package as a <code>handlers</code> variable, which can be a mapping from exception types or HTTP status codes to standard FastAPI exception handler functions, or a callable that expects a <code>fasthx.htmy.HTMY</code> positional argument and returns such a mapping. The latter option is useful if you want to do custom HTML rendering in an error handler.</p> <p>Error handlers must return either a <code>htmy.Component</code> or a <code>fastapi.Response</code>. Responses are returned to the client as is, and components are automatically rendered and returned as a <code>HTMLResponse</code>.</p> <p>It is important to know that rendered errors are not automatically wrapped in the root layout of your application. The main reason for this is <code>holm</code> can not always know what the client (be it HTMX or simply the browser) expects.</p> <p>The recommended way to handle this is to create an HTML skeleton component somewhere in your codebase, and use it both in the root layout and in error handlers to wrap page content. This, together with application-specific exceptions make it easy to handle every error correctly with minimal manual effort.</p> <p>Also, you can simply return redirect responses in error handlers that navigate users to the appropriate error page, passing context as query parameters.</p>"},{"location":"guides/custom-applications/","title":"Custom applications","text":"<p>This guide demonstrates how to use a custom FastAPI application and <code>fasthx.htmy.HTMY</code> instance (HTML renderer) in your <code>holm</code> application. This allows you to leverage <code>holm</code>'s features while keeping full control over all underlying software components.</p> <p>In the vast majority of applications, using a default FastAPI application (one created by simply calling <code>FastAPI()</code>, as <code>holm</code> internally does) is not enough. Exception handlers, for example, can be registered with <code>holm</code>, but you often need to set up a lifespan method, register middlewares, or customize the OpenAPI documentation to your needs. As a matter of fact, you could even add routes to your application manually, just make sure their paths don't conflict with the routes <code>holm</code> registers for you automatically!</p> <p>When it comes to HTML rendering, you may occasionally need to configure the <code>fasthx.htmy.HTMY</code> instance with custom request processors, formatters, translation utilities, or global rendering context.</p> <p>Doing all of this in <code>holm</code> is very straightforward, all you need to do is:</p> <ol> <li>Create a <code>FastAPI</code> instance somewhere in your codebase and configure it, just like you would do in any FastAPI project.</li> <li>Create a <code>fasthx.htmy.HTMY</code> instance and configure it.</li> <li>Pass the created instances to the <code>holm.App()</code> function as <code>App(app=my_fastapi_instance, htmy=my_htmy_instance)</code>.</li> </ol> <p>The below example demonstrates these steps as simply as possible, through creating:</p> <ul> <li>a <code>FastAPI</code> instance with a <code>/health-check</code> route, and</li> <li>a <code>fasthx.htmy.HTMY</code> instance with a request processor.</li> </ul> <p>If you followed the quick-start-guide, then you can make these changes in the <code>main.py</code> file and immediately see the result in action.</p> <pre><code>from fastapi import FastAPI\nfrom fasthx.htmy import HTMY\n\nfrom holm import App\n\napp = FastAPI()\nhtmy = HTMY(\n    request_processors=[\n        # Add a request processor that inserts an \"is_htmx_request\" key\n        # into htmy rendering contexts, making this information available\n        # to htmy components as `context[\"is_htmx_request\"]`.\n        lambda request: {\"is_htmx_request\": request.headers.get(\"HX-Request\") == \"true\"}\n    ]\n)\n\n\n@app.get(\"/health-check\")\ndef health_check() -&gt; dict[str, str]:\n    \"\"\"Health check route registered directly on the FastAPI application.\"\"\"\n    return {\"status\": \"ok\"}\n\n\n# If holm.App() receives a FastAPI application instance, then it does its job and\n# returns the same object. This means you don't need to keep a separate reference\n# to the returned value, the already existing app variable is enough.\nApp(app=app, htmy=htmy)\n</code></pre> <p>That's it! If you start the application and open its OpenAPI documentation (<code>http://localhost:8000/docs</code>) in your browser, you will see the health check route you registered, in addition to all the routes <code>holm</code> discovered and registered automatically for you.</p> <p>Note: If you return a <code>htmy</code> component from a manually registered route, it will not be rendered as HTML automatically! The reason for this is simple: <code>holm</code> must not modify the behavior of user-defined application parts in any way. You can still do HTML rendering manually using the <code>htmy</code> instance in the same way as in <code>holm</code> API modules (see the Rendering APIs with HTMX guide).</p>"},{"location":"guides/error-handling/","title":"Error handling","text":"<p>This short guide demonstrates how to add error handling to your <code>holm</code> application. We'll build upon the quick start guide.</p> <p>Before you continue, make sure you have the basic application from the quick start guide working, as we will be expanding that application.</p> <p>As a reminder, you must write standard FastAPI error handlers (async functions with a <code>Request</code> and an <code>Exception</code> argument), as you would in any FastAPI application. The only difference is that error handlers can return <code>htmy.Component</code>s as well as FastAPI <code>Response</code> objects.</p> <p>For additional rules and recommendations on error handling, please read the corresponding section of the Application components guide.</p> <p>With all that said, let's set up error handling by adding the <code>error.py</code> file to the root of our project (next to <code>main.py</code>).</p> <p>With the file in place, we need to:</p> <ul> <li>Create a standard FastAPI error handler that returns a component (<code>handle_404()</code> function).</li> <li>Create a <code>handlers</code> variable that maps HTTP error codes or exception types to the corresponding error handler.</li> </ul> <pre><code>from fastapi import Request\nfrom htmy import Component, html\n\nfrom holm import FastAPIErrorHandler\n\n\nasync def handle_404(request: Request, exc: Exception) -&gt; Component:\n    \"\"\"Handle 404 Not Found errors with a custom HTML page.\"\"\"\n    return html.div(\n        html.h1(\"Page not found\"),\n        html.p(\"The page you're looking for doesn't exist.\"),\n        html.a(\"Go back home\", href=\"/\")\n    )\n\n\nhandlers: dict[int | type[Exception], FastAPIErrorHandler] = {\n    404: handle_404,\n}\n\"\"\"Dictionary that maps HTTP error codes or exception types to error handlers.\"\"\"\n</code></pre> <p>That's it! <code>holm</code> automatically discovers your error handlers, registers them in the application, and renders components as usual.</p> <p>To test your work, you should run your application using <code>uvicorn</code> or <code>fastapi-cli</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>You can now open your browser and navigate to a non-existent page, such as <code>http://localhost:8000/does-not-exist</code> to see your custom HTTP 404 page in action.</p>"},{"location":"guides/path-parameters/","title":"Path parameters and dynamic routing","text":"<p>This guide demonstrates how to create pages with dynamic routes in a <code>holm</code> application. We'll build a simple application that lists users and shows a profile page for each user, with the user ID as a path parameter (dynamic URL segment).</p> <p>We will cover:</p> <ul> <li>How to create dynamic routes using <code>holm</code>'s file-system-based routing.</li> <li>How to access path parameters in your page and metadata functions.</li> <li>How to execute async code in pages, layouts, or metadata functions.</li> <li>How to generate dynamic metadata for pages with dynamic routes.</li> <li>How to use FastAPI dependencies to fetch data and share it between application components.</li> </ul> <p>The entire source code of this application can be found in the examples/path-parameters directory of the repository.</p> <p>This guide focuses on path parameters and dynamic routing, and has a lot in common with the Quick start guide. It is assumed you have the necessary dependencies installed, as described in the quick start guide.</p>"},{"location":"guides/path-parameters/#application-structure","title":"Application structure","text":"<p>Our application will have a home page, a page listing all users, and a dynamic page for individual user profiles. The corresponding file structure looks like this:</p> <pre><code>my_app/\n\u251c\u2500\u2500 layout.py\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 page.py\n\u2514\u2500\u2500 user/\n    \u251c\u2500\u2500 _id_/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 page.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 page.py\n    \u2514\u2500\u2500 service.py\n</code></pre> <p>The most interesting part is the <code>user/_id_/page.py</code> module. <code>holm</code> interprets the <code>_id_</code> package name as a path parameter named <code>id</code>, and creates the <code>/user/{id}</code> route for it. It lets you have <code>id: IdType</code> dependencies in page, metadata, and layout functions in this package (including its subpackages).</p>"},{"location":"guides/path-parameters/#application-initialization","title":"Application initialization","text":"<p>Let's start with <code>main.py</code>, our application's entry point. It's just two lines of code:</p> <pre><code>from holm import App\n\napp = App()\n</code></pre>"},{"location":"guides/path-parameters/#data-model-and-services","title":"Data model and services","text":"<p>Let's continue by implementing the <code>user/service.py</code> module. It acts as our data layer, and defines a <code>User</code> model and two <code>async</code> functions for fetching users. Think of it as a simple in-memory database with an <code>async</code> interface for demonstration.</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass(frozen=True, kw_only=True, slots=True)\nclass User:\n    \"\"\"User model.\"\"\"\n\n    id: int\n    name: str\n    email: str\n\n\nusers_by_id: dict[int, User] = {\n    i: User(id=i, name=f\"User {i}\", email=f\"user-{i}@holm.ccm\") for i in range(10)\n}\n\"\"\"Dictionary that maps user IDs to the corresponding user objects.\"\"\"\n\n\nasync def list_users() -&gt; list[User]:\n    \"\"\"\n    Lists all users.\n\n    The function is async to demonstrate how easily async tools, for example ORMs\n    can be used in `holm`.\n    \"\"\"\n    return list(users_by_id.values())\n\n\nasync def get_user(id: int) -&gt; User | None:\n    \"\"\"\n    Returns the user with the given ID, if the user exists.\n\n    The function is async to demonstrate how easily async tools, for example ORMs\n    can be used in `holm`.\n    \"\"\"\n    return users_by_id.get(id)\n</code></pre> <p>We now have everything in place to start working on the user interface!</p>"},{"location":"guides/path-parameters/#root-layout-and-home-page","title":"Root layout and home page","text":"<p>When it comes to the user interface, we should start with the application's layout and home page (<code>layout.py</code> and <code>page.py</code>, next to <code>main.py</code>).</p> <p>These are essentially the same as what we implemented in the Quick start guide, with minor changes in the layout's <code>nav</code> element and page content, so we won't go into the details here.</p> <p>Here is the layout (<code>layout.py</code>):</p> <pre><code>from htmy import Component, ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n\n@component\ndef layout(children: ComponentType, context: Context) -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    metadata = Metadata.from_context(context)\n    title = \"Admin App\"\n    # Let pages set only their subpage title, and add the application name automatically.\n    if subpage_title := metadata.get(\"title\"):\n        title = f\"{title} | {subpage_title}\"\n\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                html.title(title),\n                html.meta(charset=\"utf-8\"),\n                html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n                html.link(  # Use PicoCSS to add some default styling.\n                    rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n                ),\n            ),\n            html.body(\n                html.header(\n                    html.nav(\n                        html.ul(\n                            html.li(html.a(\"Home\", href=\"/\")),\n                            html.li(html.a(\"Users\", href=\"/user\")),\n                        )\n                    ),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 Admin App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre> <p>And here is the home page (<code>page.py</code>, next to <code>main.py</code>):</p> <pre><code>from htmy import Component, html\n\n# Static metadata for this page\nmetadata = {\"title\": \"Dashboard\"}\n\n\ndef page() -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return html.div(\n        html.h1(\"Welcome to Admin App\"),\n        html.p(\"This is a minimal holm application demonstrating:\"),\n        html.ul(\n            html.li(\"How to use path parameters, also known as dynamic routing\"),\n            html.li(\"File-system based routing with dynamic routes\"),\n        ),\n        html.a(\"Navigate to the User page to start exploring\", href=\"/user\"),\n    )\n</code></pre>"},{"location":"guides/path-parameters/#the-user-list-page","title":"The user list page","text":"<p>Next, we'll create the users page at the <code>/user</code> URL (<code>user/page.py</code>).</p> <p>This page uses the <code>list_users()</code> service to load the list of users, and displays them as a HTML list. Each list item contains an anchor tag that we can use to navigate to the user's profile page.</p> <pre><code>from htmy import Component, html\n\nfrom .service import list_users\n\nmetadata: dict[str, str] = {\"title\": \"Users\"}\n\n\nasync def page() -&gt; Component:\n    # Load users using an async service.\n    users = await list_users()\n    return html.div(\n        html.h1(\"Users:\"),\n        html.ul(\n            # Create list items with a link to the profile page for each user.\n            # Don't forget to use the spread operator! html.ul expects its\n            # children as positional arguments, not as a single list.\n            *(html.li(html.a(user.name, href=f\"/user/{user.id}\")) for user in users),\n        ),\n    )\n</code></pre>"},{"location":"guides/path-parameters/#user-profile-page","title":"User profile page","text":"<p>We have finally reached the essence of this guide: the user profile page. Don't expect any magic though.</p> <p>As explained at the start, <code>holm</code> automatically creates the <code>/user/{id}</code> URL for the page in the <code>user/_id_/page.py</code> module, so you can have <code>id: int</code> dependencies in page and metadata (even layout) functions. Or, as you will see and as you may expect if you are familiar with FastAPI, dependencies that depend on <code>id: int</code> in some way. The <code>id</code> argument is of course resolved from the <code>id</code> path parameter.</p> <p>With that said, let's create the user profile page:</p> <pre><code>from typing import Annotated\n\nfrom fastapi import Depends\nfrom htmy import html\n\nfrom ..service import User, get_user\n\n# The `get_user()` function expects an `id: int`. The argument's name and type\n# matches the `{id}` path parameter, which means we can use `get_user()` as\n# a FastAPI dependency without any additional work (FastAPI will resolve the\n# `id: int` argument correctly from the `{id}` path parameter)! Let's do this.\nDependsUser = Annotated[User | None, Depends(get_user)]\n\n\ndef metadata(id: int, user: DependsUser) -&gt; dict[str, str]:\n    \"\"\"\n    Metadata function that uses the `DependsUser` annotated FastAPI dependency\n    to get the user whose ID was submitted in the `{id}` path parameter (which\n    is the URL segment corresponding to the `_id_` package name.)\n\n    Just to show that the user was indeed loaded based on the submitted ID,\n    the metadata function also uses the `id: int` argument, that is resolved\n    by FastAPI from the `{id}` path parameter.\n    \"\"\"\n    user_title = \"Not Found\" if user is None else user.name\n    if user and user.id != id:\n        raise ValueError(\n            \"id and user.id should match, because both values originate \"\n            \"from the `{id}` path parameter the client submitted.\"\n        )\n    return {\n        \"title\": f\"User | {user_title}\",\n    }\n\n\nasync def page(user: DependsUser) -&gt; html.div:\n    \"\"\"\n    Page function that uses the `DependsUser` annotated FastAPI dependency\n    to get the user whose ID was submitted in the `{id}` path parameter.\n\n    FastAPI resolves each dependency once, meaning we're only loading the user\n    once, and we share it between application components through FastAPI's\n    dependency injection system.\n    \"\"\"\n    if user is None:\n        return html.div(\n            html.h1(\"The user does not exist\"),\n        )\n\n    return html.div(\n        html.strong(\"Name:\"),\n        html.span(user.name),\n        html.strong(\"ID:\"),\n        html.span(str(user.id)),\n        html.strong(\"Email:\"),\n        html.span(user.email),\n        style=\"display: grid; grid-template-columns: max-content 1fr; gap: 1rem;\",\n    )\n</code></pre> <p>Here is a summary of the key takeaways:</p> <ul> <li>Packages names of <code>_identifier_</code> format correspond to <code>{identifier}</code> URL segments.</li> <li><code>{identifier}</code> URL segments are FastAPI path parameters, and thus they enable dynamic routing.</li> <li>The <code>get_user(id: int)</code> service function can be used as a FastAPI dependency to conveniently get access to the requested user in page, metadata, and layout functions. This is also efficient, because FastAPI resolves each dependency only once.</li> </ul>"},{"location":"guides/path-parameters/#run-the-application","title":"Run the application","text":"<p>That's it! You can now run your application using <code>uvicorn</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with <code>fastapi-cli</code> if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>You can now open your browser, navigate to <code>http://localhost:8000/</code>, and start exploring your application in action.</p>"},{"location":"guides/quick-start-guide/","title":"Quick start guide","text":"<p>Let's create a minimal <code>holm</code> application with a layout, two pages, and dynamic page metadata!</p> <p>This example will get you up and running quickly by demonstrating the following core concepts:</p> <ul> <li>File-system routing: URLs automatically match your directory structure (<code>/about</code> maps to <code>about/page.py</code>).</li> <li>Automatic layout composition: The root layout automatically wraps all pages without manual configuration.</li> <li>Dynamic metadata: Pages can have static metadata (a mapping) or dynamic metadata (as a FastAPI dependency).</li> <li>FastAPI integration: Use standard FastAPI features (dependencies) in layouts, pages, and metadata functions.</li> <li>htmy components: Build your UI in typed Python with a JSX-like syntax.</li> </ul> <p>The entire source code of this application can be found in the examples/quick-start-guide directory of the repository.</p> <p>Before you continue, make sure you have installed <code>holm</code> and either <code>uvicorn</code> or <code>fastapi-cli</code> (<code>pip install holm uvicorn</code> or <code>pip install holm fastapi-cli</code>)!</p>"},{"location":"guides/quick-start-guide/#create-the-application-structure","title":"Create the application structure","text":"<p>First, create the following directory structure:</p> <pre><code>my_app/\n\u251c\u2500\u2500 main.py          # Application entry point\n\u251c\u2500\u2500 layout.py        # Root layout\n\u251c\u2500\u2500 page.py          # Home page\n\u2514\u2500\u2500 about/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 page.py      # About page\n</code></pre>"},{"location":"guides/quick-start-guide/#initialize-your-application","title":"Initialize your application","text":"<p>Create <code>main.py</code> to initialize your <code>holm</code> application:</p> <pre><code>from holm import App\n\napp = App()\n</code></pre> <p>This is all you need! The <code>App()</code> call will automatically discover and register all your layouts and pages based on the folder structure.</p>"},{"location":"guides/quick-start-guide/#create-a-root-layout","title":"Create a root layout","text":"<p>Create <code>layout.py</code> to define your application's root layout:</p> <pre><code>from htmy import Component, ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n\n@component\ndef layout(children: ComponentType, context: Context) -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    metadata = Metadata.from_context(context)\n\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                html.title(metadata.get(\"title\", \"My App\")),\n                html.meta(charset=\"utf-8\"),\n                html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n                html.link(  # Use PicoCSS to add some default styling.\n                    rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n                ),\n            ),\n            html.body(\n                html.header(\n                    html.nav(\n                        html.ul(\n                            html.li(html.a(\"Home\", href=\"/\")),\n                            html.li(html.a(\"About\", href=\"/about\")),\n                        )\n                    ),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 My App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre> <p>It is a usual, minimal HTML document, which uses PicoCSS to add some default styling.</p> <p>The layout itself is a <code>htmy</code> function component. This makes the <code>htmy</code> rendering context available in the layout (see the <code>context</code> argument). Page metadata is added to the <code>htmy</code> context by pages that define a <code>metadata</code> mapping or function. Being able to access the metadata (with <code>Metadata.from_context(context)</code>) is important, because this is how <code>htmy</code> components (in this case the layout) can get access to page-specific information, such as the desired page title.</p>"},{"location":"guides/quick-start-guide/#create-your-home-page","title":"Create your home page","text":"<p>Create <code>page.py</code> for your home page:</p> <pre><code>from htmy import Component, html\n\n# Static metadata for this page\nmetadata = {\"title\": \"Home | My App\"}\n\n\ndef page() -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return html.div(\n        html.h1(\"Welcome to My App\"),\n        html.p(\"This is a minimal holm application demonstrating:\"),\n        html.ul(\n            html.li(\"File-system based routing\"),\n            html.li(\"Automatic layout composition\"),\n            html.li(\"Dynamic metadata\"),\n            html.li(\"Server-side rendering with htmy\"),\n        ),\n        html.a(\"Learn more about us\", href=\"/about\"),\n    )\n</code></pre> <p>There are three interesting parts in the page implementation:</p> <ul> <li>How <code>metadata</code> is set by the page to provide the title for the layout.</li> <li>There is no manual page rendering: <code>page</code> is a simple FastAPI dependency, the value it returns is passed to its owner layout as is (see the layout's first argument), and <code>holm</code> takes care of rendering automatically.</li> <li>There is no explicit FastAPI route registration, <code>holm</code> does it automatically for you.</li> </ul>"},{"location":"guides/quick-start-guide/#create-an-about-page-with-dynamic-metadata","title":"Create an about page with dynamic metadata","text":"<p>Create <code>about/__init__.py</code> (empty file) and <code>about/page.py</code>:</p> <pre><code>from htmy import Component, html\n\n\nasync def metadata(featured: bool = False) -&gt; dict[str, str]:\n    \"\"\"\n    Dynamic metadata based on query parameters.\n\n    This function could be both sync or async. It's just a standard FastAPI dependency.\n    \"\"\"\n    title = \"Featured About\" if featured else \"About\"\n    return {\"title\": f\"{title} | My App\"}\n\n\nasync def page(featured: bool = False) -&gt; Component:\n    \"\"\"Async about page with dynamic content.\"\"\"\n    if featured:\n        return html.div(\n            html.h1(\"About Us \u2b50\"),\n            html.p(\"This is our featured about page!\"),\n            html.p(\"You're viewing the special featured version.\"),\n            html.a(\"Regular version\", href=\"/about\"),\n        )\n\n    return html.div(\n        html.h1(\"About Us\"),\n        html.p(\"We're building amazing web applications with holm.\"),\n        html.p(\"Our framework combines the power of FastAPI with server-side rendering.\"),\n        html.a(\"Featured version\", href=\"/about?featured=true\"),\n    )\n</code></pre> <p>The about page differs from the home page in two important aspects.</p> <p>First is the <code>metadata</code>, which is a function in this case, or more precisely a FastAPI dependency, that returns the metadata mapping for the page. Being a FastAPI dependency means that if a <code>featured</code> query parameter is provided, it will be automatically passed to this function by FastAPI. You could of course use any other FastAPI dependency here.</p> <p>Second is the <code>page</code> function, which also has a <code>featured</code> query parameter. As you might have guessed, just like <code>metadata</code>, <code>page</code> is also a FastAPI dependency. In this case these two dependencies have the same arguments, but it is not necessary to be like this! <code>page</code> and <code>metadata</code> could both have totally different dependencies, <code>holm</code> and FastAPI takes care of their correct handling for you!</p> <p>That's it! You now have a working application. From here, you can add more pages, create nested layouts, add API endpoints, and explore the full power of FastAPI, <code>htmy</code>, and FastHX.</p>"},{"location":"guides/quick-start-guide/#run-your-application","title":"Run your application","text":"<p>You can now run your application using <code>uvicorn</code> or <code>fastapi-cli</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>Visit these URLs to see your application in action:</p> <ul> <li><code>http://localhost:8000/</code>: Home page</li> <li><code>http://localhost:8000/about</code>: About page</li> <li><code>http://localhost:8000/about?featured=true</code>: About page with dynamic content</li> </ul>"},{"location":"guides/rendering-apis-with-htmx/","title":"Rendering APIs with HTMX","text":"<p>This guide demonstrates how to enhance a basic <code>holm</code> application with a rendering API and HTMX for dynamic, interactive web applications. We'll build upon the quick start guide to add server-rendered partial updates and seamless navigation.</p> <p>Very basic familiarity with HTMX is helpful for this guide, but it can be followed even without it.</p> <p>Before you continue, make sure you have the basic application from the quick start guide working, as we will be expanding that application.</p> <p>We will cover:</p> <ul> <li>How to integrate HTMX for dynamic content updates.</li> <li>How to enhance navigation with the <code>hx-boost</code> HTMX attribute.</li> <li>How to create API endpoints that return rendered HTML components, often called fragments or partials.</li> <li>How to use fasthx for seamless server-side rendering of htmy components.</li> </ul> <p>The entire source code of this application can be found in the examples/rendering-apis-with-htmx directory of the repository.</p>"},{"location":"guides/rendering-apis-with-htmx/#add-htmx-to-the-application","title":"Add HTMX to the application","text":"<p>Modify <code>layout.py</code> to include the HTMX script and enable <code>hx-boost</code> on the <code>nav</code> tag for enhanced navigation:</p> <pre><code>from htmy import Component, ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n\n@component\ndef layout(children: ComponentType, context: Context) -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    metadata = Metadata.from_context(context)\n\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                html.title(metadata.get(\"title\", \"My App\")),\n                html.meta(charset=\"utf-8\"),\n                html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n                html.link(  # Use PicoCSS to add some default styling.\n                    rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n                ),\n                html.script(src=\"https://unpkg.com/htmx.org@2.0.7\"),\n            ),\n            html.body(\n                html.header(\n                    html.nav(\n                        html.ul(\n                            html.li(html.a(\"Home\", href=\"/\")),\n                            html.li(html.a(\"About\", href=\"/about\")),\n                        ),\n                        hx_boost=\"true\",\n                    ),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 My App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre> <p>The changes in the layout are trivial, we simply:</p> <ul> <li>added the HTMX script tag to the <code>head</code> element of the webpage with <code>html.script(src=\"https://unpkg.com/htmx.org@2.0.7\")</code>;</li> <li>and set the <code>hx_boost</code> attribute on the <code>nav</code> element in the page <code>header</code> to boost our anchors.</li> </ul>"},{"location":"guides/rendering-apis-with-htmx/#create-the-rendering-api","title":"Create the rendering API","text":"<p>Next we create our rendering API in an <code>api.py</code> module. We will place it at the root of our project (next to <code>main.py</code>), because we want this API to exist directly under the root <code>/</code> URL prefix.</p> <p>Note: <code>holm</code> applies file-system based routing to both pages and APIs! Actually, if both an API (<code>api.py</code>) and a page (<code>page.py</code>) exists in a directory, <code>holm</code> combines their routes into a single <code>APIRouter</code> for that path. API routes are registered first, followed by the page route at <code>GET</code> <code>/</code>. This means if your API defines a <code>GET</code> <code>/</code> route, it will conflict with your page route.</p> <p>The API we create will be very simple, it will have a single <code>/welcome-message</code> route that returns a welcome message in a randomly chosen language. The returned message is itself a <code>htmy</code> <code>Component</code>, so all we need to do is decorate the path operation function with <code>@htmy.hx()</code>. You can learn more about using <code>fasthx.htmy.HTMY</code> here.</p> <pre><code>import random\n\nfrom fastapi import APIRouter\nfrom fasthx.htmy import HTMY\n\n_welcome_message: list[str] = [\n    \"Welcome to My App! Powered By HTMX.\",\n    \"Bienvenido a My App! Powered By HTMX.\",\n    \"Bienvenue dans My App! Powered By HTMX.\",\n    \"Willkommen bei My App! Powered By HTMX.\",\n    \"Benvenuti nella mia app! Powered By HTMX.\",\n    \"\u00dcdv\u00f6z\u00f6lj\u00fck a My App-ban! Powered By HTMX.\",\n]\n\n\ndef api(htmy: HTMY) -&gt; APIRouter:\n    \"\"\"Rendering API factories need a `htmy: fasthx.htmy.HTMY` argument.\"\"\"\n    api = APIRouter()\n\n    @api.get(\"/welcome-message\")\n    @htmy.hx()  # type: ignore[arg-type]\n    async def get_welcome_message() -&gt; str:\n        return random.choice(_welcome_message)  # noqa: S311\n\n    return api\n</code></pre> <p>Important details:</p> <ul> <li>The <code>htmy.hx()</code> decorator is responsible for rendering the route's return value. It must be wrapped by the <code>@api</code> decorator.</li> <li>Within the <code>api()</code> function, everything is standard FastAPI and FastHX functionality.</li> <li>While this example only adds a rendering route, you can freely mix rendering and JSON APIs.</li> </ul>"},{"location":"guides/rendering-apis-with-htmx/#add-dynamic-behavior-to-the-home-page","title":"Add dynamic behavior to the home page","text":"<p>Finally we add dynamic content to the home page (<code>page.py</code> in the root directory) with a couple of simple HTMX attributes.</p> <p>On the <code>h1</code> element, which contains our welcome message, we set:</p> <ul> <li><code>hx_get</code> to the use our newly created <code>/welcome-message</code> route when HTMX is triggered.</li> <li><code>hx_trigger</code> to <code>every 2s</code> to make the page load a new welcome message from our API every 2 seconds.</li> </ul> <p>These two attributes together will replace the displayed welcome message every two seconds without reloading the entire page.</p> <p>For the sake of completeness, we also wrap the link at the bottom in a <code>div</code> and use <code>hx_boost</code> as before to enhance the navigation experience.</p> <pre><code>from htmy import Component, html\n\n# Static metadata for this page\nmetadata = {\"title\": \"Home | My App\"}\n\n\ndef page() -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return html.div(\n        html.h1(\n            \"Welcome to My App\",\n            hx_get=\"/welcome-message\",\n            hx_trigger=\"every 2s\",\n        ),\n        html.p(\"This is a minimal holm application demonstrating:\"),\n        html.ul(\n            html.li(\"File-system based routing\"),\n            html.li(\"Automatic layout composition\"),\n            html.li(\"Dynamic metadata\"),\n            html.li(\"Server-side rendering with htmy\"),\n        ),\n        html.div(\n            html.a(\"Learn more about us\", href=\"/about\"),\n            hx_boost=\"true\",  # Explicit hx-boost for this link\n        ),\n    )\n</code></pre> <p>That's it! You can now run your application using <code>uvicorn</code> or <code>fastapi-cli</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>You can now open your browser and navigate to <code>http://localhost:8000/</code> to see your application in action.</p> <p>If you followed every step correctly, then you will see the welcome message changing every two seconds on the home page.</p> <p>If you are curious to see how your API is called and how it responds, you can inspect requests on the Network tab of your browser's developer tools.</p>"}]}