{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"holm","text":"<p>Web development framework that brings the Next.js developer experience to Python, built on FastAPI, <code>htmy</code>, and FastHX.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Next.js-like developer experience with file-system based routing and page composition.</li> <li>Standard FastAPI everywhere, so you can leverage the entire FastAPI ecosystem.</li> <li>JSX-like syntax with async support for components, thanks to <code>htmy</code>.</li> <li>First class HTMX support with <code>FastHX</code>.</li> <li>Async support everywhere, from APIs and dependencies all the way to UI components.</li> <li>Support for both JSON and HTML (server side rendering) APIs.</li> <li>No JavaScript dependencies</li> <li>No build steps, just server side rendering with fully typed Python.</li> <li>Stability by building only on the core feature set of dependent libraries.</li> <li>Unopinionated: use any CSS framework for styling and any JavaScript framework for UI interactivity.</li> </ul>"},{"location":"#testimonials","title":"Testimonials","text":"<p>\"Thanks for your work in the <code>holm</code>/<code>htmy</code>/<code>FastHX</code> stack, it's awesome.\" (David Brochart, Technical Director at QuantStack, Jupyter developer. ref)</p>"},{"location":"#pre-requisite-knowledge","title":"Pre-requisite knowledge","text":"<p>To get started, all you need is a basic understanding of:</p> <ul> <li>FastAPI: the underlying web framework.</li> <li>HTML and CSS fundamentals.</li> </ul> <p>The <code>holm</code> in a hurry guide walks you through all the essentials in under five minutes, and helps you build up all the intuition you need to start using <code>holm</code> effectively.</p> <p>For a deeper understanding of <code>holm</code>, it is recommended to also read the Application components document and the Quick start guide.</p> <p>Checking out the htmy documentation can help you understand how components and HTML rendering works in <code>holm</code>.</p> <p>It is recommended to use HTMX, if for nothing else, then to avoid hard page loads on navigation. hx-boost (or navigation with <code>hx-get</code>) offers the same benefits as the <code>Link</code> component in Next.js.</p> <p>Familiarity with FastHX (the rendering layer between <code>htmy</code> and <code>FastAPI</code>), and its <code>htmy</code> integration can occasionally be useful, but not necessary at all.</p>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI and can be installed with:</p> <pre><code>pip install holm\n</code></pre> <p>Supported operating systems:</p> <ul> <li>Linux</li> <li>macOS</li> <li>Windows</li> </ul>"},{"location":"#support","title":"Support","text":"<p>Consider supporting the development and maintenance of the project through sponsoring, or reach out for consulting so you can get the most out of the library.</p>"},{"location":"#application-structure","title":"Application structure","text":"<p>Similarly to Next.js, <code>holm</code> is built around the concept of file-system based routing. This essentially means that your code structure is automatically mapped to a matching API:</p> <ul> <li>You do not need to manually define routes, every application component is automatically discovered and registered in the application.</li> <li>You do not need to manually wrap pages in their layouts, it is automatically done based on your application's code structure.</li> </ul> <p>You can find all the necessary details on the Application components page, and the Quick start guide can walk you through the process of creating your first application. The two are complementary documents, reading both is strongly recommended.</p> <p>HTML rendering is also fully automated, in the vast majority of cases you do not need to concern yourself with that (the only exceptions are HTML APIs, more on that in the Rendering APIs with HTMX guide).</p> <p>All you need to do is follow these simple rules:</p> <ul> <li>You must initialize your application instance using <code>holm.App()</code>. It optionally accepts a base <code>FastAPI</code> application and a <code>fasthx.htmy.HTMY</code> instance that handles HTML rendering.</li> <li><code>holm.App()</code> must be called directly within a module in your root application package to make automatic application discovery work.</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>The documentation contains guides and example applications for every major feature. They all build on the Quick start guide, so that is the best place to start if you prefer to learn through examples.</p> <p>You can discover even more nuances by exploring the test application of the project.</p> <p>If you are looking for the simplest possible application you can create, then you can find it in the examples/minimal directory of the repository.</p>"},{"location":"#ai-assistance","title":"AI assistance","text":"<p>The library and all its dependencies are registered at Context7.</p> <p>To get good AI assistance, all you need to do is register the Context7 MCP server in your coding tool and tell the agent to use it.</p> <p>If you are starting a new project, you can additionally point the agent at one of the example applications in the repository. With all this context and detailed instructions of the project you want to build, it will get you started quickly.</p> <p>Because of the similarity with Next.js and React, and the standard use of FastAPI and other dependencies, you can expect good results, both for vibe coding or inline completion.</p>"},{"location":"#technical-notes","title":"Technical notes","text":""},{"location":"#performance","title":"Performance","text":"<p>Automatic application discovery and route registration takes only marginally more time compared to manual route registration. The performance difference during startup is unnoticeable.</p> <p>When it comes to serving requests, there are two cases: standard JSON APIs and web applications.</p> <p>For JSON APIs, the performance overhead is zero. In this case you are only using the application discovery feature of <code>holm</code>.</p> <p>When building web applications, performance should be compared to an application that does all the rendering manually in routes, using <code>htmy</code>. In this case, a <code>holm</code> application will typically need to resolve a couple of additional dependencies, but because of the efficiency of FastAPI's dependency resolution mechanism, the performance impact is still unnoticeable.</p>"},{"location":"#templating-language-support","title":"Templating language support","text":"<p>While certain features in <code>holm</code> rely heavily on the capabilities of <code>htmy</code> (for example its context and async support), you can still use other DSLs or templating languages (for example Jinja) in your application if you would like to. All you need to do is write a simple wrapper <code>htmy</code> component that internally offloads rendering to your framework of choice. You can find out more about this in the htmy documentation.</p>"},{"location":"#development","title":"Development","text":"<p>Development setup:</p> <ul> <li><code>uv</code> for project and dependency management.</li> <li><code>poethepoet</code> for running tasks. Run <code>uv run poe</code> to see all available tasks.</li> <li><code>mypy</code> for static code analysis.</li> <li><code>ruff</code> is used for formatting and linting.</li> <li><code>pytest</code> for testing.</li> <li><code>mkdocs-material</code> and <code>mkdocstrings</code> for documentation.</li> </ul> <p>Tests are located in the <code>tests</code> directory and they use the application defined in the <code>test_app</code> package (through a <code>TestClient</code>). This setup makes it possible to run <code>test_app</code> outside of tests, which is useful for debugging.</p> <p>You can run all tests with <code>uv run poe test</code>. You can separately start the test application with <code>uv run poe test-app</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community to help improve the project! Whether you're an experienced developer or just starting out, there are many ways you can contribute:</p> <ul> <li>Discuss: Join our Discussion Board to ask questions, share ideas, provide feedback, and engage with the community.</li> <li>Document: Help improve the documentation by fixing typos, adding examples, and updating guides to make it easier for others to use the project.</li> <li>Develop: Prototype requested features or pick up issues from the issue tracker.</li> <li>Test: Write tests to improve coverage and reliability.</li> </ul>"},{"location":"#comparison-with-other-frameworks","title":"Comparison with other frameworks","text":""},{"location":"#frameworks-with-javascript-dependencies","title":"Frameworks with JavaScript dependencies","text":"<p>The most prominent frameworks in this category are Reflex and NiceGUI. They both provide a Python-first web development experience while using complex JavaScript frameworks under the hood for constructing user interfaces (namely React and Vue.js). They take care of state management and synchronization (using WebSockets), seamlessly connecting the JavaScript frontend and the Python backend. In exchange for this convenience comes complexity and heavy reliance on the ever-changing JavaScript ecosystem.</p> <p><code>holm</code> comes with no JavaScript dependencies, but that doesn't mean you can't use JavaScript to add frontend interactivity. In fact, it comes with first class HTMX support and naturally works with frameworks like Alpine.js. Web component frameworks like lit, and even React application segments can also be integrated, just like into any server rendered page.</p>"},{"location":"#pure-server-side-rendering-frameworks","title":"Pure server-side rendering frameworks","text":"<p>This category includes frameworks like FastHTML or Ludic, and this is where <code>holm</code> belongs as well, but it has some key differentiators.</p> <p>First, <code>holm</code> brings the Next.js developer experience to Python with file-system based routing, automatic layout composition, and dynamic page metadata creation, and more. Thanks to <code>htmy</code>, it supports async code throughout the stack, even in components, and it also solves the prop drilling problem. While being built with <code>htmy</code>, it is easy to integrate with other templating libraries, like <code>Jinja</code> or <code>htpy</code>. And it provides all these features using standard, simple FastAPI patterns.</p>"},{"location":"#license","title":"License","text":"<p>The package is open-sourced under the conditions of the MIT license.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#holm.App","title":"<code>holm.App(*, app=None, htmy=None)</code>","text":"<p>Creates a FastAPI application with all the routes that are defined in the application package.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI | None</code> <p>Optional FastAPI application to use. If <code>None</code>, a new instance will be created.</p> <code>None</code> <code>htmy</code> <code>HTMY | None</code> <p>Optional <code>fasthx.htmy.HTMY</code> instance to use for server-side rendering. If <code>None</code>, a default instance will be created.</p> <code>None</code> Source code in <code>holm/app.py</code> <pre><code>def App(*, app: FastAPI | None = None, htmy: HTMY | None = None) -&gt; FastAPI:\n    \"\"\"\n    Creates a FastAPI application with all the routes that are defined in the application package.\n\n    Arguments:\n        app: Optional FastAPI application to use. If `None`, a new instance will be created.\n        htmy: Optional `fasthx.htmy.HTMY` instance to use for server-side rendering. If `None`,\n            a default instance will be created.\n    \"\"\"\n    if app is None:\n        app = FastAPI()\n\n    if htmy is None:\n        htmy = HTMY()\n\n    config = AppConfig.default()\n    packages = _discover_app_packages(config)\n    root_node = _build_app_tree(packages)\n\n    # Register error handlers\n    if pkg := root_node.package:\n        register_error_handlers(app, load_error_handler_owner(pkg), htmy=htmy)\n\n    # Build the API\n    app.include_router(_build_api(root_node, htmy=htmy))\n\n    return app\n</code></pre>"},{"location":"api/#holm.Metadata","title":"<code>holm.Metadata</code>","text":"<p>               Bases: <code>ContextAware</code></p> <p>Context-aware metadata provider.</p> <p>The class implements the <code>Mapping</code> protocol as a means of giving convenient access to the metadata it contains.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>class Metadata(ContextAware):\n    \"\"\"\n    Context-aware metadata provider.\n\n    The class implements the `Mapping` protocol as a means of giving convenient access to\n    the metadata it contains.\n    \"\"\"\n\n    __slots__ = (\"_metadata\",)\n\n    def __init__(self, metadata: MetadataMapping | None = None) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            metadata: The actual metadata mapping.\n        \"\"\"\n        self._metadata = {} if metadata is None else metadata\n        \"\"\"The metadata mapping.\"\"\"\n\n    @overload\n    def get(self, key: Any, default: None = None) -&gt; Any | None: ...\n\n    @overload\n    def get(self, key: Any, default: Any) -&gt; Any: ...\n\n    def get(self, key: Any, default: Any | None = None) -&gt; Any | None:\n        \"\"\"Implements `Mapping.get()`.\"\"\"\n        return self._metadata.get(key, default)\n\n    def __contains__(self, key: Any) -&gt; bool:\n        \"\"\"Implements the `Container` protocol.\"\"\"\n        return key in self._metadata\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return isinstance(other, Metadata) and self._metadata == other._metadata\n\n    def __getitem__(self, key: Any) -&gt; Any:\n        \"\"\"Implements the `Sequence` protocol.\"\"\"\n        return self._metadata[key]\n\n    def __iter__(self) -&gt; Iterator[Any]:\n        \"\"\"Implements the `Iterable` protocol.\"\"\"\n        return iter(self._metadata)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Implements the `Sized` protocol.\"\"\"\n        return len(self._metadata)\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self.__eq__(other)\n\n    def items(self) -&gt; ItemsView[Any, Any]:\n        \"\"\"Implements `Mapping.items()`.\"\"\"\n        return self._metadata.items()\n\n    def keys(self) -&gt; KeysView[Any]:\n        \"\"\"Implements `Mapping.keys()`.\"\"\"\n        return self._metadata.keys()\n\n    def values(self) -&gt; ValuesView[Any]:\n        \"\"\"Implements `Mapping.values()`.\"\"\"\n        return self._metadata.values()\n</code></pre>"},{"location":"api/#holm.Metadata.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Implements the <code>Container</code> protocol.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def __contains__(self, key: Any) -&gt; bool:\n    \"\"\"Implements the `Container` protocol.\"\"\"\n    return key in self._metadata\n</code></pre>"},{"location":"api/#holm.Metadata.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Implements the <code>Sequence</code> protocol.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def __getitem__(self, key: Any) -&gt; Any:\n    \"\"\"Implements the `Sequence` protocol.\"\"\"\n    return self._metadata[key]\n</code></pre>"},{"location":"api/#holm.Metadata.__iter__","title":"<code>__iter__()</code>","text":"<p>Implements the <code>Iterable</code> protocol.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Any]:\n    \"\"\"Implements the `Iterable` protocol.\"\"\"\n    return iter(self._metadata)\n</code></pre>"},{"location":"api/#holm.Metadata.__len__","title":"<code>__len__()</code>","text":"<p>Implements the <code>Sized</code> protocol.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Implements the `Sized` protocol.\"\"\"\n    return len(self._metadata)\n</code></pre>"},{"location":"api/#holm.Metadata.get","title":"<code>get(key, default=None)</code>","text":"<pre><code>get(key: Any, default: None = None) -&gt; Any | None\n</code></pre><pre><code>get(key: Any, default: Any) -&gt; Any\n</code></pre> <p>Implements <code>Mapping.get()</code>.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def get(self, key: Any, default: Any | None = None) -&gt; Any | None:\n    \"\"\"Implements `Mapping.get()`.\"\"\"\n    return self._metadata.get(key, default)\n</code></pre>"},{"location":"api/#holm.Metadata.items","title":"<code>items()</code>","text":"<p>Implements <code>Mapping.items()</code>.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def items(self) -&gt; ItemsView[Any, Any]:\n    \"\"\"Implements `Mapping.items()`.\"\"\"\n    return self._metadata.items()\n</code></pre>"},{"location":"api/#holm.Metadata.keys","title":"<code>keys()</code>","text":"<p>Implements <code>Mapping.keys()</code>.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def keys(self) -&gt; KeysView[Any]:\n    \"\"\"Implements `Mapping.keys()`.\"\"\"\n    return self._metadata.keys()\n</code></pre>"},{"location":"api/#holm.Metadata.values","title":"<code>values()</code>","text":"<p>Implements <code>Mapping.values()</code>.</p> Source code in <code>holm/module_options/_metadata.py</code> <pre><code>def values(self) -&gt; ValuesView[Any]:\n    \"\"\"Implements `Mapping.values()`.\"\"\"\n    return self._metadata.values()\n</code></pre>"},{"location":"api/#holm.action","title":"<code>holm.action</code>","text":"<p>Decorators for registering actions.</p> <p>Decorator arguments map directly to the corresponding FastAPI route decorator's arguments, unless the documentation states otherwise.</p> Source code in <code>holm/module_options/_actions.py</code> <pre><code>class action:\n    \"\"\"\n    Decorators for registering actions.\n\n    Decorator arguments map directly to the corresponding FastAPI route decorator's arguments,\n    unless the documentation states otherwise.\n    \"\"\"\n\n    @classmethod\n    def __call__(\n        cls,\n        path: str | None = None,\n        *,\n        use_layout: bool = False,\n        metadata: MetadataMappingOrDependency | None = None,\n        methods: Collection[HTTPMethod] | None = None,\n        dependencies: Sequence[DependsParam] | None = None,\n        deprecated: bool | None = None,\n        tags: list[str | Enum] | None = None,\n    ) -&gt; ActionDependencyDecorator:\n        \"\"\"\n        Decorator for registering an action with arbitrary HTTP `methods`.\n\n        Corresponding FastAPI route decorator: `APIRouter.api_route()`.\n\n        Arguments:\n            use_layout: Whether to render the action's return value in the\n                containing package's layout (same as a page).\n            metadata: Metadata mapping or dependency for the action. The equivalent\n                of page metadata for actions.\n            path: The action's path (within the package's `APIRouter`). If `None`,\n                the decorated function's name is used as the path.\n        \"\"\"\n\n        def decorator(func: ActionDependency) -&gt; ActionDependency:\n            cls._register_action(\n                func,\n                use_layout=use_layout,\n                metadata=metadata,\n                path=path,\n                dependencies=dependencies,\n                deprecated=deprecated,\n                methods=methods,\n                tags=tags,\n            )\n            return func\n\n        return decorator\n\n    @classmethod\n    def get(\n        cls,\n        path: str | None = None,\n        *,\n        use_layout: bool = False,\n        metadata: MetadataMappingOrDependency | None = None,\n        dependencies: Sequence[DependsParam] | None = None,\n        deprecated: bool | None = None,\n        tags: list[str | Enum] | None = None,\n    ) -&gt; ActionDependencyDecorator:\n        \"\"\"\n        Decorator for registering an action with an HTTP GET method.\n\n        Corresponding FastAPI route decorator: `APIRouter.get()`.\n\n        Arguments:\n            use_layout: Whether to render the action's return value in the\n                containing package's layout (same as a page).\n            metadata: Metadata mapping or dependency for the action. The equivalent\n                of page metadata for actions.\n            path: The action's path (within the package's `APIRouter`). If `None`,\n                the decorated function's name is used as the path.\n        \"\"\"\n\n        def decorator(func: ActionDependency) -&gt; ActionDependency:\n            cls._register_action(\n                func,\n                use_layout=use_layout,\n                metadata=metadata,\n                path=path,\n                dependencies=dependencies,\n                deprecated=deprecated,\n                methods=(\"GET\",),\n                tags=tags,\n            )\n            return func\n\n        return decorator\n\n    @classmethod\n    def post(\n        cls,\n        path: str | None = None,\n        *,\n        use_layout: bool = False,\n        metadata: MetadataMappingOrDependency | None = None,\n        dependencies: Sequence[DependsParam] | None = None,\n        deprecated: bool | None = None,\n        tags: list[str | Enum] | None = None,\n    ) -&gt; ActionDependencyDecorator:\n        \"\"\"\n        Decorator for registering an action with an HTTP POST method.\n\n        Corresponding FastAPI route decorator: `APIRouter.post()`.\n\n        Arguments:\n            use_layout: Whether to render the action's return value in the\n                containing package's layout (same as a page).\n            metadata: Metadata mapping or dependency for the action. The equivalent\n                of page metadata for actions.\n            path: The action's path (within the package's `APIRouter`). If `None`,\n                the decorated function's name is used as the path.\n        \"\"\"\n\n        def decorator(func: ActionDependency) -&gt; ActionDependency:\n            cls._register_action(\n                func,\n                use_layout=use_layout,\n                metadata=metadata,\n                path=path,\n                dependencies=dependencies,\n                deprecated=deprecated,\n                methods=(\"POST\",),\n                tags=tags,\n            )\n            return func\n\n        return decorator\n\n    @classmethod\n    def put(\n        cls,\n        path: str | None = None,\n        *,\n        use_layout: bool = False,\n        metadata: MetadataMappingOrDependency | None = None,\n        dependencies: Sequence[DependsParam] | None = None,\n        deprecated: bool | None = None,\n        tags: list[str | Enum] | None = None,\n    ) -&gt; ActionDependencyDecorator:\n        \"\"\"\n        Decorator for registering an action with an HTTP PUT method.\n\n        Corresponding FastAPI route decorator: `APIRouter.put()`.\n\n        Arguments:\n            use_layout: Whether to render the action's return value in the\n                containing package's layout (same as a page).\n            metadata: Metadata mapping or dependency for the action. The equivalent\n                of page metadata for actions.\n            path: The action's path (within the package's `APIRouter`). If `None`,\n                the decorated function's name is used as the path.\n        \"\"\"\n\n        def decorator(func: ActionDependency) -&gt; ActionDependency:\n            cls._register_action(\n                func,\n                use_layout=use_layout,\n                metadata=metadata,\n                path=path,\n                dependencies=dependencies,\n                deprecated=deprecated,\n                methods=(\"PUT\",),\n                tags=tags,\n            )\n            return func\n\n        return decorator\n\n    @classmethod\n    def patch(\n        cls,\n        path: str | None = None,\n        *,\n        use_layout: bool = False,\n        metadata: MetadataMappingOrDependency | None = None,\n        dependencies: Sequence[DependsParam] | None = None,\n        deprecated: bool | None = None,\n        tags: list[str | Enum] | None = None,\n    ) -&gt; ActionDependencyDecorator:\n        \"\"\"\n        Decorator for registering an action with an HTTP PATCH method.\n\n        Corresponding FastAPI route decorator: `APIRouter.patch()`.\n\n        Arguments:\n            use_layout: Whether to render the action's return value in the\n                containing package's layout (same as a page).\n            metadata: Metadata mapping or dependency for the action. The equivalent\n                of page metadata for actions.\n            path: The action's path (within the package's `APIRouter`). If `None`,\n                the decorated function's name is used as the path.\n        \"\"\"\n\n        def decorator(func: ActionDependency) -&gt; ActionDependency:\n            cls._register_action(\n                func,\n                use_layout=use_layout,\n                metadata=metadata,\n                path=path,\n                dependencies=dependencies,\n                deprecated=deprecated,\n                methods=(\"PATCH\",),\n                tags=tags,\n            )\n            return func\n\n        return decorator\n\n    @classmethod\n    def delete(\n        cls,\n        path: str | None = None,\n        *,\n        use_layout: bool = False,\n        metadata: MetadataMappingOrDependency | None = None,\n        dependencies: Sequence[DependsParam] | None = None,\n        deprecated: bool | None = None,\n        tags: list[str | Enum] | None = None,\n    ) -&gt; ActionDependencyDecorator:\n        \"\"\"\n        Decorator for registering an action with an HTTP DELETE method.\n\n        Corresponding FastAPI route decorator: `APIRouter.delete()`.\n\n        Arguments:\n            use_layout: Whether to render the action's return value in the\n                containing package's layout (same as a page).\n            metadata: Metadata mapping or dependency for the action. The equivalent\n                of page metadata for actions.\n            path: The action's path (within the package's `APIRouter`). If `None`,\n                the decorated function's name is used as the path.\n        \"\"\"\n\n        def decorator(func: ActionDependency) -&gt; ActionDependency:\n            cls._register_action(\n                func,\n                use_layout=use_layout,\n                metadata=metadata,\n                path=path,\n                dependencies=dependencies,\n                deprecated=deprecated,\n                methods=(\"DELETE\",),\n                tags=tags,\n            )\n            return func\n\n        return decorator\n\n    @classmethod\n    def _register_action(\n        cls,\n        action: ActionDependency,\n        *,\n        use_layout: bool,\n        metadata: MetadataMappingOrDependency | None,\n        path: str | None,\n        tags: list[str | Enum] | None,\n        **route_args: Any,\n    ) -&gt; None:\n        \"\"\"\n        Registers the given action in the module that contains it.\n\n        Arguments:\n            use_layout: Whether to render the action's return value in the\n                containing package's layout (same as a page).\n            metadata: Metadata mapping or dependency for the action. The equivalent\n                of page metadata for actions.\n            path: The action's path (within the package's `APIRouter`). If `None`,\n                the decorated function's name is used as the path.\n        \"\"\"\n        action_module = action.__module__\n        action_name = action.__name__\n        module = sys.modules[action_module]\n        module_actions: ActionDescriptors | None = getattr(module, _actions_variable, None)\n        if module_actions is None:\n            module_actions = {}\n            setattr(module, _actions_variable, module_actions)\n\n        if path is None:\n            path = f\"/{action_name.replace('_', '-')}\"\n\n        route_args[\"name\"] = f\"{action_module}.{action_name}\"\n        # Use the Action tag if no tags were set by the user.\n        route_args[\"tags\"] = [\"Action\"] if tags is None else tags\n        route_args[\"response_model\"] = None  # Don't generate a response schema.\n\n        # Register the action.\n        module_actions[path] = ActionDescriptor(\n            action=action,\n            route_args=route_args,\n            use_layout=use_layout,\n            metadata=metadata,\n        )\n</code></pre>"},{"location":"api/#holm.action.get","title":"<code>get(path=None, *, use_layout=False, metadata=None, dependencies=None, deprecated=None, tags=None)</code>  <code>classmethod</code>","text":"<p>Decorator for registering an action with an HTTP GET method.</p> <p>Corresponding FastAPI route decorator: <code>APIRouter.get()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>use_layout</code> <code>bool</code> <p>Whether to render the action's return value in the containing package's layout (same as a page).</p> <code>False</code> <code>metadata</code> <code>MetadataMappingOrDependency | None</code> <p>Metadata mapping or dependency for the action. The equivalent of page metadata for actions.</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The action's path (within the package's <code>APIRouter</code>). If <code>None</code>, the decorated function's name is used as the path.</p> <code>None</code> Source code in <code>holm/module_options/_actions.py</code> <pre><code>@classmethod\ndef get(\n    cls,\n    path: str | None = None,\n    *,\n    use_layout: bool = False,\n    metadata: MetadataMappingOrDependency | None = None,\n    dependencies: Sequence[DependsParam] | None = None,\n    deprecated: bool | None = None,\n    tags: list[str | Enum] | None = None,\n) -&gt; ActionDependencyDecorator:\n    \"\"\"\n    Decorator for registering an action with an HTTP GET method.\n\n    Corresponding FastAPI route decorator: `APIRouter.get()`.\n\n    Arguments:\n        use_layout: Whether to render the action's return value in the\n            containing package's layout (same as a page).\n        metadata: Metadata mapping or dependency for the action. The equivalent\n            of page metadata for actions.\n        path: The action's path (within the package's `APIRouter`). If `None`,\n            the decorated function's name is used as the path.\n    \"\"\"\n\n    def decorator(func: ActionDependency) -&gt; ActionDependency:\n        cls._register_action(\n            func,\n            use_layout=use_layout,\n            metadata=metadata,\n            path=path,\n            dependencies=dependencies,\n            deprecated=deprecated,\n            methods=(\"GET\",),\n            tags=tags,\n        )\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/#holm.action.post","title":"<code>post(path=None, *, use_layout=False, metadata=None, dependencies=None, deprecated=None, tags=None)</code>  <code>classmethod</code>","text":"<p>Decorator for registering an action with an HTTP POST method.</p> <p>Corresponding FastAPI route decorator: <code>APIRouter.post()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>use_layout</code> <code>bool</code> <p>Whether to render the action's return value in the containing package's layout (same as a page).</p> <code>False</code> <code>metadata</code> <code>MetadataMappingOrDependency | None</code> <p>Metadata mapping or dependency for the action. The equivalent of page metadata for actions.</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The action's path (within the package's <code>APIRouter</code>). If <code>None</code>, the decorated function's name is used as the path.</p> <code>None</code> Source code in <code>holm/module_options/_actions.py</code> <pre><code>@classmethod\ndef post(\n    cls,\n    path: str | None = None,\n    *,\n    use_layout: bool = False,\n    metadata: MetadataMappingOrDependency | None = None,\n    dependencies: Sequence[DependsParam] | None = None,\n    deprecated: bool | None = None,\n    tags: list[str | Enum] | None = None,\n) -&gt; ActionDependencyDecorator:\n    \"\"\"\n    Decorator for registering an action with an HTTP POST method.\n\n    Corresponding FastAPI route decorator: `APIRouter.post()`.\n\n    Arguments:\n        use_layout: Whether to render the action's return value in the\n            containing package's layout (same as a page).\n        metadata: Metadata mapping or dependency for the action. The equivalent\n            of page metadata for actions.\n        path: The action's path (within the package's `APIRouter`). If `None`,\n            the decorated function's name is used as the path.\n    \"\"\"\n\n    def decorator(func: ActionDependency) -&gt; ActionDependency:\n        cls._register_action(\n            func,\n            use_layout=use_layout,\n            metadata=metadata,\n            path=path,\n            dependencies=dependencies,\n            deprecated=deprecated,\n            methods=(\"POST\",),\n            tags=tags,\n        )\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/#holm.action.put","title":"<code>put(path=None, *, use_layout=False, metadata=None, dependencies=None, deprecated=None, tags=None)</code>  <code>classmethod</code>","text":"<p>Decorator for registering an action with an HTTP PUT method.</p> <p>Corresponding FastAPI route decorator: <code>APIRouter.put()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>use_layout</code> <code>bool</code> <p>Whether to render the action's return value in the containing package's layout (same as a page).</p> <code>False</code> <code>metadata</code> <code>MetadataMappingOrDependency | None</code> <p>Metadata mapping or dependency for the action. The equivalent of page metadata for actions.</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The action's path (within the package's <code>APIRouter</code>). If <code>None</code>, the decorated function's name is used as the path.</p> <code>None</code> Source code in <code>holm/module_options/_actions.py</code> <pre><code>@classmethod\ndef put(\n    cls,\n    path: str | None = None,\n    *,\n    use_layout: bool = False,\n    metadata: MetadataMappingOrDependency | None = None,\n    dependencies: Sequence[DependsParam] | None = None,\n    deprecated: bool | None = None,\n    tags: list[str | Enum] | None = None,\n) -&gt; ActionDependencyDecorator:\n    \"\"\"\n    Decorator for registering an action with an HTTP PUT method.\n\n    Corresponding FastAPI route decorator: `APIRouter.put()`.\n\n    Arguments:\n        use_layout: Whether to render the action's return value in the\n            containing package's layout (same as a page).\n        metadata: Metadata mapping or dependency for the action. The equivalent\n            of page metadata for actions.\n        path: The action's path (within the package's `APIRouter`). If `None`,\n            the decorated function's name is used as the path.\n    \"\"\"\n\n    def decorator(func: ActionDependency) -&gt; ActionDependency:\n        cls._register_action(\n            func,\n            use_layout=use_layout,\n            metadata=metadata,\n            path=path,\n            dependencies=dependencies,\n            deprecated=deprecated,\n            methods=(\"PUT\",),\n            tags=tags,\n        )\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/#holm.action.patch","title":"<code>patch(path=None, *, use_layout=False, metadata=None, dependencies=None, deprecated=None, tags=None)</code>  <code>classmethod</code>","text":"<p>Decorator for registering an action with an HTTP PATCH method.</p> <p>Corresponding FastAPI route decorator: <code>APIRouter.patch()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>use_layout</code> <code>bool</code> <p>Whether to render the action's return value in the containing package's layout (same as a page).</p> <code>False</code> <code>metadata</code> <code>MetadataMappingOrDependency | None</code> <p>Metadata mapping or dependency for the action. The equivalent of page metadata for actions.</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The action's path (within the package's <code>APIRouter</code>). If <code>None</code>, the decorated function's name is used as the path.</p> <code>None</code> Source code in <code>holm/module_options/_actions.py</code> <pre><code>@classmethod\ndef patch(\n    cls,\n    path: str | None = None,\n    *,\n    use_layout: bool = False,\n    metadata: MetadataMappingOrDependency | None = None,\n    dependencies: Sequence[DependsParam] | None = None,\n    deprecated: bool | None = None,\n    tags: list[str | Enum] | None = None,\n) -&gt; ActionDependencyDecorator:\n    \"\"\"\n    Decorator for registering an action with an HTTP PATCH method.\n\n    Corresponding FastAPI route decorator: `APIRouter.patch()`.\n\n    Arguments:\n        use_layout: Whether to render the action's return value in the\n            containing package's layout (same as a page).\n        metadata: Metadata mapping or dependency for the action. The equivalent\n            of page metadata for actions.\n        path: The action's path (within the package's `APIRouter`). If `None`,\n            the decorated function's name is used as the path.\n    \"\"\"\n\n    def decorator(func: ActionDependency) -&gt; ActionDependency:\n        cls._register_action(\n            func,\n            use_layout=use_layout,\n            metadata=metadata,\n            path=path,\n            dependencies=dependencies,\n            deprecated=deprecated,\n            methods=(\"PATCH\",),\n            tags=tags,\n        )\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/#holm.action.delete","title":"<code>delete(path=None, *, use_layout=False, metadata=None, dependencies=None, deprecated=None, tags=None)</code>  <code>classmethod</code>","text":"<p>Decorator for registering an action with an HTTP DELETE method.</p> <p>Corresponding FastAPI route decorator: <code>APIRouter.delete()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>use_layout</code> <code>bool</code> <p>Whether to render the action's return value in the containing package's layout (same as a page).</p> <code>False</code> <code>metadata</code> <code>MetadataMappingOrDependency | None</code> <p>Metadata mapping or dependency for the action. The equivalent of page metadata for actions.</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The action's path (within the package's <code>APIRouter</code>). If <code>None</code>, the decorated function's name is used as the path.</p> <code>None</code> Source code in <code>holm/module_options/_actions.py</code> <pre><code>@classmethod\ndef delete(\n    cls,\n    path: str | None = None,\n    *,\n    use_layout: bool = False,\n    metadata: MetadataMappingOrDependency | None = None,\n    dependencies: Sequence[DependsParam] | None = None,\n    deprecated: bool | None = None,\n    tags: list[str | Enum] | None = None,\n) -&gt; ActionDependencyDecorator:\n    \"\"\"\n    Decorator for registering an action with an HTTP DELETE method.\n\n    Corresponding FastAPI route decorator: `APIRouter.delete()`.\n\n    Arguments:\n        use_layout: Whether to render the action's return value in the\n            containing package's layout (same as a page).\n        metadata: Metadata mapping or dependency for the action. The equivalent\n            of page metadata for actions.\n        path: The action's path (within the package's `APIRouter`). If `None`,\n            the decorated function's name is used as the path.\n    \"\"\"\n\n    def decorator(func: ActionDependency) -&gt; ActionDependency:\n        cls._register_action(\n            func,\n            use_layout=use_layout,\n            metadata=metadata,\n            path=path,\n            dependencies=dependencies,\n            deprecated=deprecated,\n            methods=(\"DELETE\",),\n            tags=tags,\n        )\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/#holm.action.__call__","title":"<code>__call__(path=None, *, use_layout=False, metadata=None, methods=None, dependencies=None, deprecated=None, tags=None)</code>  <code>classmethod</code>","text":"<p>Decorator for registering an action with arbitrary HTTP <code>methods</code>.</p> <p>Corresponding FastAPI route decorator: <code>APIRouter.api_route()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>use_layout</code> <code>bool</code> <p>Whether to render the action's return value in the containing package's layout (same as a page).</p> <code>False</code> <code>metadata</code> <code>MetadataMappingOrDependency | None</code> <p>Metadata mapping or dependency for the action. The equivalent of page metadata for actions.</p> <code>None</code> <code>path</code> <code>str | None</code> <p>The action's path (within the package's <code>APIRouter</code>). If <code>None</code>, the decorated function's name is used as the path.</p> <code>None</code> Source code in <code>holm/module_options/_actions.py</code> <pre><code>@classmethod\ndef __call__(\n    cls,\n    path: str | None = None,\n    *,\n    use_layout: bool = False,\n    metadata: MetadataMappingOrDependency | None = None,\n    methods: Collection[HTTPMethod] | None = None,\n    dependencies: Sequence[DependsParam] | None = None,\n    deprecated: bool | None = None,\n    tags: list[str | Enum] | None = None,\n) -&gt; ActionDependencyDecorator:\n    \"\"\"\n    Decorator for registering an action with arbitrary HTTP `methods`.\n\n    Corresponding FastAPI route decorator: `APIRouter.api_route()`.\n\n    Arguments:\n        use_layout: Whether to render the action's return value in the\n            containing package's layout (same as a page).\n        metadata: Metadata mapping or dependency for the action. The equivalent\n            of page metadata for actions.\n        path: The action's path (within the package's `APIRouter`). If `None`,\n            the decorated function's name is used as the path.\n    \"\"\"\n\n    def decorator(func: ActionDependency) -&gt; ActionDependency:\n        cls._register_action(\n            func,\n            use_layout=use_layout,\n            metadata=metadata,\n            path=path,\n            dependencies=dependencies,\n            deprecated=deprecated,\n            methods=methods,\n            tags=tags,\n        )\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/#holm.without_layout","title":"<code>holm.without_layout</code>  <code>dataclass</code>","text":"<p>Marker that signals that the component it contains should not be wrapped by the application in any parent layouts.</p> <p>This utility must only be used as a return value wrapper in application components whose return value could be wrapped in a parent layout by <code>holm</code>. For example pages, submit handlers, layouts.</p> <p>Attempting to render an instance of this class results in a <code>RuntimeError</code>. The only reason it implements the <code>htmy()</code> method is to make static code analysis tools accept it as an <code>htmy.Component</code>.</p> Source code in <code>holm/modules/_layout.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass without_layout:\n    \"\"\"\n    Marker that signals that the component it contains should not be\n    wrapped by the application in any parent layouts.\n\n    This utility must only be used as a return value wrapper in application\n    components whose return value could be wrapped in a parent layout by\n    `holm`. For example pages, submit handlers, layouts.\n\n    Attempting to render an instance of this class results in a `RuntimeError`.\n    The only reason it implements the `htmy()` method is to make static code\n    analysis tools accept it as an `htmy.Component`.\n    \"\"\"\n\n    component: Component\n    \"\"\"The wrapped component.\"\"\"\n\n    def htmy(self, _: Any) -&gt; Component:\n        raise RuntimeError(f\"{type(self).__name__} must never be part of the htmy component tree!\")\n</code></pre>"},{"location":"api/#holm.ErrorHandlerMapping","title":"<code>holm.ErrorHandlerMapping = Mapping[type[Exception] | int, FastAPIErrorHandler]</code>  <code>module-attribute</code>","text":"<p>Mapping type whose keys are exception types or HTTP status codes, and the corresponding values are FastAPI error handlers.</p>"},{"location":"application-components/","title":"Application components","text":"<p>This section summarizes the different components of <code>holm</code> applications. If you have used Next.js before, you will find these concepts very familiar. If not, don't worry, they may seem complex at first, but they are quite intuitive and natural.</p>"},{"location":"application-components/#layouts-and-pages","title":"Layouts and pages","text":"<p>Layouts are defined in the <code>layout.py</code> modules of packages as a callable <code>layout</code> variable (note that for example classes with an <code>__init__()</code> method, or <code>htmy.Component</code>s are callable, so they also qualify).</p> <p>Rules for layouts:</p> <ul> <li>The root layout must always return a <code>htmy.Component</code>.</li> <li><code>layout</code> must be a callable and it must accept a positional argument (other than <code>self</code> if the layout is a method of a class), the data / properties of the layout that are returned by the pages or layouts this layout directly wraps.</li> <li><code>layout</code> can have additional arguments (position or keyword and keyword-only, but not positional-only). These arguments must be FastAPI dependencies. They will be automatically resolved during each request.</li> <li>Returning a tuple or a list from a layout is not allowed unless the value is a <code>htmy.ComponentSequence</code>. Tuples and lists are always interpreted and treated as component sequences, so you don't need to track what kinds of components pages and layouts return. See <code>htmy.is_component_sequence()</code> for more information.</li> </ul> <p>By default, layouts automatically wrap all layouts and pages in subpackages. You can opt out of this behavior by wrapping the return value of a layout or page with the <code>without_layout</code> utility.</p> <p>Tip: layouts can provide context for their entire subtree by wrapping the subtree with a <code>htmy</code> <code>ContextProvider</code> component.</p> <p>Pages are defined in the <code>page.py</code> module of packages as a callable <code>page</code> variable (note that classes with an <code>__init__()</code> method are callable, so they also qualify).</p> <p>Rules for pages:</p> <ul> <li><code>page</code> must be a FastAPI dependency, meaning it can have any arguments as long as they can all be resolved by FastAPI as dependencies.</li> <li><code>page</code> must return the properties object for the layout that directly wraps it.</li> <li>If a page is not wrapped by a layout, then it must return a <code>htmy.Component</code>.</li> <li>Returning a tuple or a list from a page is not allowed unless the value is a <code>htmy.ComponentSequence</code>. Tuples and lists are always interpreted and treated as component sequences, so you don't need to track what kinds of components pages and layouts return. See <code>htmy.is_component_sequence()</code> for more information.</li> <li><code>page</code> can directly return a FastAPI <code>Response</code> as well, which is always returned as is.</li> </ul>"},{"location":"application-components/#page-metadata","title":"Page metadata","text":"<p><code>page.py</code> modules can have a <code>metadata</code> variable, which can be an arbitrary mapping or a FastAPI dependency that returns an arbitrary mapping.</p> <p>If the <code>metadata</code> variable is a callable, it can have any FastAPI dependencies, even different ones than what the <code>page</code> or wrapper layouts use.</p> <p>The metadata provided by the currently served page is made available to every <code>htmy.Component</code> (from the root layout to the page itself) through the built-in <code>Metadata</code> utility. It can be accessed as <code>Metadata.from_context(context)</code> where <code>context</code> is the <code>htmy</code> rendering context which is passed to every component. See the htmy documentation for more information.</p> <p>This feature is particularly useful when page-specific information - for example title, description, or keywords - must be set dynamically (for example, in layouts) on a page-by-page basis. <code>Metadata</code> implements the <code>Mapping</code> protocol, so once loaded from the <code>htmy</code> rendering context in a component with <code>metadata = Metadata.from_context(context)</code>, you can use it simply like this to set page-specific information in any layout, component, or the page itself: <code>htmy.html.title(metadata[\"title\"])</code>.</p>"},{"location":"application-components/#page-submit-handlers","title":"Page submit handlers","text":"<p><code>page.py</code> modules can also define a callable <code>handle_submit</code> variable. The same rendering logic and rules apply to it as to the <code>page</code> variable itself. The only difference is that for <code>handle_submit</code>, a HTTP <code>POST</code> route is created.</p> <p><code>handle_submit</code>, together with <code>page</code>, offer a convenient way to handle form submission in your application.</p> <p>The default HTML <code>&lt;form&gt;</code> action is to submit the form to the current URL using a HTTP GET request. This means if you have a form in your <code>page</code> (or <code>layout</code>), and you do not set <code>action</code> and <code>method</code>, your form's submission will be handled by your current <code>page</code> by default (your GET route). This is useful for search and filtering forms for example.</p> <p>For forms that trigger state change on the server, you should set the form <code>method</code> to <code>POST</code>. This is important from a CSRF prevention perspective, and it also ensures the submitted form will be handled by your <code>handle_submit</code> function (your POST route), instead of your <code>page</code> function.</p> <p>You can of course set <code>action</code> to some URL. In that case the same logic applies, but instead of triggering the <code>page</code> or <code>handle_submit</code> function that belong to the current URL, it will trigger them in the <code>page.py</code> or <code>api.py</code> module that handles the given URL.</p>"},{"location":"application-components/#actions","title":"Actions","text":"<p>Actions provide a convenient and flexible way to create custom HTML rendering routes that don't fit the standard <code>page</code> pattern. They are functions decorated with one of the <code>@action</code> decorators (<code>@action.get()</code>, <code>@action.post()</code>, etc.), and they can be defined in either a <code>page.py</code> or <code>actions.py</code> module.</p> <p>Rules for actions:</p> <ul> <li>An action must be a FastAPI dependency, just like a page.</li> <li>Actions can be registered with any HTTP method (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>), using the appropriate <code>@action</code> decorator.</li> <li>You can specify a custom URL path for an action (e.g., <code>@action.post(\"/do-something\")</code>), but it is optional. If no path is provided, the function's name is used as the path, with underscores (<code>_</code>) being replaced by hyphens (<code>-</code>). In both cases, the path is relative to the URL corresponding to the package that contains the action.</li> <li>By default, components returned from actions are not wrapped in layouts. This is ideal for returning HTML fragments for client frameworks like HTMX.</li> <li>To render an action's return value in its owner layouts (like it is done by default for pages), you can set <code>use_layout=True</code> in the decorator: <code>@action.get(use_layout=True)</code>. This behavior can of course be combined with the <code>without_layout</code> utility.</li> <li>Actions can also have <code>metadata</code>: <code>@action.get(metadata={\"title\": \"Hello\"})</code>. <code>metadata</code> works identically to page metadata and is particularly useful when combined with <code>use_layout</code>.</li> <li>An action can directly return a FastAPI <code>Response</code>, which is always returned as is.</li> </ul>"},{"location":"application-components/#apis","title":"APIs","text":"<p>APIs are defined in the <code>api.py</code> module or packages as an <code>APIRouter</code> variable or a callable that returns an <code>APIRouter</code>.</p> <p><code>api.py</code> modules serve two primary use-cases:</p> <ul> <li>They allow creating a custom <code>APIRouter</code> configuration for the package, for example by adding <code>APIRouter</code> dependencies.</li> <li>They allow creating standard FastAPI routes that serve JSON.</li> </ul> <p>These are standard FastAPI <code>APIRouter</code>s, but you should still follow these recommendations:</p> <ul> <li>If routes in the API don't do any rendering, then the <code>api()</code> callable should have no arguments or simply an <code>api</code> variable should be used.</li> <li>If the API has rendering routes, the <code>api()</code> callable should have a single <code>fasthx.htmy.HTMY</code> positional argument. The application's renderer will be passed to this function automatically by <code>holm</code>.</li> <li>If an <code>api()</code> callable is used, it may have further arguments as long as they all have default values. This pattern can simplify API testing for example, by allowing custom configurations for tests.</li> </ul> <p>Note on rendering APIs:</p> <ul> <li>They are a lower-level alternative to actions. In most cases, you should prefer using actions instead: they are simpler and more powerful.</li> <li>The primary role of these APIs is to return so called \"partials\" (small HTML snippets instead of entire HTML pages) to clients such as HTMX for swapping.</li> <li>The components returned by rendering routes are not automatically wrapped in layouts like pages are.</li> </ul>"},{"location":"application-components/#path-parameters-as-package-names","title":"Path parameters as package names","text":"<p>Routes with path parameters, also often referred to as \"dynamic routes\", are essential to almost all applications. A simple example is a user profile page, served at <code>/user/{id}</code> for example, where we want to display information about the user with the given ID.</p> <p>You can capture dynamic URL path parameters by using special package names. Two formats are supported:</p> <ul> <li><code>_param_</code> format: package names like <code>_id_</code> or <code>_user_id_</code>.</li> <li><code>{param}</code> format: package names like <code>{id}</code> or <code>{user_id}</code>. (Note: it works with <code>holm</code>, but static code analysis tools flag it because <code>{id}</code> is not a valid Python identifier.)</li> </ul> <p>Both formats are converted to FastAPI path parameters. For example:</p> <ul> <li>File path <code>user/_id_/page.py</code> becomes URL <code>/user/{id}</code>.</li> <li>File path <code>user/{user_id}/settings/page.py</code> becomes URL <code>/user/{user_id}/settings</code>.</li> </ul> <p>Any layout or page within these packages can access the path parameter as a FastAPI dependency by adding it to their function signature (e.g., <code>id: int</code> or <code>user_id: str</code>).</p>"},{"location":"application-components/#private-packages","title":"Private packages","text":"<p>You can prefix package names with one or more underscores to opt the entire package (including its subpackages) out of the automatic application component discovery.</p> <p>For example, if you have a package named <code>_private</code> somewhere in your application folder, you can freely place valid page, layout, or API files within it or its subpackages. These modules will not be processed and included in the application.</p> <p>Reminder: if the package name also ends with an underscore, it will be treated as a path parameter, as described above.</p>"},{"location":"application-components/#error-handling","title":"Error handling","text":"<p>Error handlers are defined in the <code>error.py</code> or <code>errors.py</code> module of the root package as a <code>handlers</code> variable, which can be a mapping from exception types or HTTP status codes to standard FastAPI exception handler functions, or a callable that expects a <code>fasthx.htmy.HTMY</code> positional argument and returns such a mapping. The latter option is useful if you want to do custom HTML rendering in an error handler.</p> <p>Error handlers must return either a <code>htmy.Component</code> or a <code>fastapi.Response</code>. Responses are returned to the client as is, and components are automatically rendered and returned as a <code>HTMLResponse</code>.</p> <p>It is important to know that rendered errors are not automatically wrapped in the root layout of your application. The main reason for this is <code>holm</code> can not always know what the client (be it HTMX or simply the browser) expects.</p> <p>The recommended way to handle this is to create an HTML skeleton component somewhere in your codebase, and use it both in the root layout and in error handlers to wrap page content. This, together with application-specific exceptions make it easy to handle every error correctly with minimal manual effort.</p> <p>Also, you can simply return redirect responses in error handlers that navigate users to the appropriate error page, passing context as query parameters.</p>"},{"location":"file-system-based-routing/","title":"File-system based routing","text":"<p><code>holm</code> uses a file-system based router, which means the structure of your project's directories and files automatically defines the routes of your application. This convention-over-configuration approach simplifies routing management and makes the project structure intuitive and predictable.</p> <p>If you have experience with Next.js, you will find this routing paradigm very familiar.</p> <p>Going through the Application components documentation is recommended before continuing this guide.</p>"},{"location":"file-system-based-routing/#core-concepts","title":"Core concepts","text":"<ul> <li>Packages define URL segments: Each Python package within your application's root maps to a URL segment. Nesting directories creates nested routes. For example, the <code>my_app/users/</code> package will create routes under the <code>/users</code> URL path.</li> <li>Underscores (<code>_</code>) are replaced with hyphens (<code>-</code>) in paths by default, unless a path segment corresponds to a path parameter, in which case the underscore is preserved.</li> <li>Special files mark application components: <code>holm</code> looks for specific filenames within your application directory to discover application components and compose your application.</li> <li><code>page.py</code>: Creates a publicly accessible URL for a route segment.</li> <li><code>layout.py</code>: Defines a shared UI that wraps a route segment and its children.</li> <li><code>actions.py</code>: Defines custom action endpoints for a route segment.</li> <li><code>api.py</code>: Creates custom API endpoints for a route segment.</li> </ul>"},{"location":"file-system-based-routing/#routing-conventions","title":"Routing conventions","text":"<p>Let's use the following project structure as an example to explore the routing conventions in <code>holm</code>.</p> <pre><code>my_app/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 layout.py\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 navbar.py\n\u251c\u2500\u2500 page.py\n\u251c\u2500\u2500 users/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 actions.py\n\u2502   \u251c\u2500\u2500 api.py\n\u2502   \u251c\u2500\u2500 layout.py\n\u2502   \u251c\u2500\u2500 page.py\n\u2502   \u2514\u2500\u2500 _user_id_/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 page.py\n\u2514\u2500\u2500 _components/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 page.py\n    \u2514\u2500\u2500 user/\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 api.py\n</code></pre>"},{"location":"file-system-based-routing/#pages-and-layouts","title":"Pages and layouts","text":"<p>A <code>page.py</code> file makes a route segment publicly accessible as (typically) an HTML page. Based on the example structure, <code>holm</code> will generate the following page routes:</p> <ul> <li><code>my_app/page.py</code> creates the root route at <code>/</code>, because <code>page.py</code> is in the root application package.</li> <li><code>my_app/users/page.py</code> creates the route at <code>/users</code>, because the page module is in the <code>users</code> package.</li> <li><code>my_app/users/_user_id_/page.py</code> creates a dynamic route at <code>/users/{user_id}</code>, because this <code>page.py</code> is in the <code>users._user_id_</code> package and <code>_user_id_</code> marks a dynamic route segment.</li> </ul> <p>Layouts defined in <code>layout.py</code> files automatically wrap layouts and pages within the same package and all subpackages.</p> <ul> <li>The layout in <code>my_app/layout.py</code> is the root layout, wrapping all layouts and pages.</li> <li>The layout in <code>my_app/users/layout.py</code> wraps the page at <code>/users</code> and the dynamic page at <code>/users/{user_id}</code>. The <code>users</code> layout is itself wrapped by the root layout.</li> </ul>"},{"location":"file-system-based-routing/#actions","title":"Actions","text":"<p>An <code>actions.py</code> file offers a dedicated place to define actions, which are flexible HTML endpoints for handling client interactions. Actions can also be defined in <code>page.py</code> modules, but if you have many actions, using <code>actions.py</code> can help with code organization.</p> <p>Actions are declared using the <code>@action</code> decorators (for example <code>@action.post()</code>). Their paths are always prefixed with the package's URL path.</p> <ul> <li>An action in <code>my_app/users/actions.py</code> (or <code>my_app/users/page.py</code>) decorated with <code>@action.post(\"/enable\")</code> creates a route that handles <code>POST /users/enable</code> requests.</li> <li>If no path is specified in the decorator, the action function's name is used with underscores (<code>_</code>) being replaced by hyphens (<code>-</code>). Decorating a <code>def deactivate_user(): ...</code> function without setting a path would create a route at <code>/users/deactivate-user</code>.</li> </ul>"},{"location":"file-system-based-routing/#apis","title":"APIs","text":"<p>An <code>api.py</code> file allows you to define standard FastAPI API endpoints for a given route segment. These can be the usual JSON endpoints or rendering APIs.</p> <p>For example, <code>my_app/users/api.py</code> can define routes like <code>GET /count</code>, <code>POST /create</code>, which will be accessible under the <code>/users</code> path prefix (<code>/users/count</code>, <code>/users/create</code>).</p> <p><code>page.py</code> files automatically add a <code>GET /</code> route, and submit handlers a corresponding <code>POST /</code> route. To avoid path collision, it's recommended to avoid adding these routes in <code>api.py</code> files.</p>"},{"location":"file-system-based-routing/#private-packages","title":"Private packages","text":"<p>You can prevent a directory and all its subdirectories from being included in the routing system by prefixing its name with an underscore (<code>_</code>). This is useful for separating components, utilities, or other files that should not be routable.</p> <p>In our example, the <code>_components/</code> directory is such a private package.</p> <ul> <li><code>my_app/_components/page.py</code> will not create a route.</li> <li><code>my_app/_components/user/api.py</code> will not create an API.</li> </ul> <p>This allows you to organize your internal components logically without exposing them as endpoints.</p> <p>_Note: A package name like <code>\\_user_id_</code> which is surrounded by underscores is treated as a dynamic route segment, not a private package._</p>"},{"location":"file-system-based-routing/#colocation","title":"Colocation","text":"<p>Besides the special files (<code>page.py</code>, <code>layout.py</code>, <code>api.py</code>, etc.), you can place any other files within your application package (the package where <code>holm.App()</code> is called). <code>holm</code> will ignore them during route discovery. This allows you to colocate your business logic and UI components with your application components.</p> <p>In the example, <code>my_app/navbar.py</code> is not a special file, so it is not routable. It can define any components or utilities, like a <code>Navbar</code>, which can then be imported and used in the layouts, pages, or APIs of the application.</p> <p><code>holm</code> also doesn't consider anything outside the application package as an application component. We could create a <code>my_components/</code> directory next to <code>my_app/</code> and have anything in it, including <code>page.py</code> files for example. The content of this package would be ignored by <code>holm</code>, it is not within the application package.</p>"},{"location":"file-system-based-routing/#submit-handlers","title":"Submit handlers","text":"<p>For any <code>page.py</code> file, you can also define a <code>handle_submit</code> function. This automatically creates a <code>POST</code> route at the same URL as the page. This is a convenient pattern for handling HTML form submissions that modify data.</p> <p>If <code>my_app/users/page.py</code> defines a <code>handle_submit</code> function, it will handle <code>POST /users</code> requests, and the <code>page</code> function in the same file will handle <code>GET /users</code> requests as usual.</p>"},{"location":"file-system-based-routing/#constructing-urls","title":"Constructing URLs","text":"<p>FastAPI provides two ways for constructing valid URLs for registered routes: <code>FastAPI.url_path_for()</code> and <code>Request.url_for()</code>. Both of these methods expect the path operation's name, and the route's path parameters (if any) as keyword arguments.</p> <p>To let you use these built-in FastAPI utilities, <code>holm</code> automatically assigns a name to every page route it registers. The name assignment logic is very simple: the name (import path) of the corresponding <code>page.py</code> module.</p> <p>Here are some examples:</p> <ul> <li><code>app.url_path_for(\"my_app.page\")</code>: <code>/</code></li> <li><code>app.url_path_for(\"my_app.users.page\")</code>: <code>/users/</code></li> <li><code>app.url_path_for(\"my_app.users._user_id_.page\", user_id=1)</code>: <code>/users/1/</code></li> </ul> <p>Submit handlers are also assigned a name: the name of the corresponding page's name, followed by the <code>.handle_submit</code> suffix. Since the only difference between pages and submit handlers is the used HTTP method, the URL for a submit handler is the same as the URL for the corresponding page.</p> <p>Actions are named using their module's import path and the action function's name: <code>{module_path}.{function_name}</code>. For an action named <code>enable_user</code> inside <code>my_app/users/actions.py</code>, the name would be <code>my_app.users.actions.enable_user</code>.</p>"},{"location":"in-a-hurry/","title":"<code>holm</code> in a hurry","text":"<p><code>holm</code> is a Python web framework that applies the development patterns of Next.js to a Python environment. It is built on:</p> <ul> <li>Standard FastAPI as its web server layer.</li> <li><code>htmy</code> as its engine for building HTML components in pure Python, with full typing and async support.</li> </ul> <p>File-system based routing takes a central role in <code>holm</code>. Instead of manually defining routes, your application's package structure is automatically discovered and mapped to a corresponding API structure. This process also included full UI composition from your layouts and pages.</p>"},{"location":"in-a-hurry/#application-initialization","title":"Application initialization","text":"<p>Your application is initialized with a single call to <code>holm.App()</code> within your application's root package. This call triggers the discovery process where <code>holm</code> walks your project structure, finds all the application components described below, and registers the corresponding routes in the underlying FastAPI instance.</p> <p><code>holm.App()</code> optionally accepts a FastAPI instance to use. If provided, it registers all routes in the given application, giving you full control over your application's configuration.</p>"},{"location":"in-a-hurry/#application-structure-and-components","title":"Application structure and components","text":"<p><code>holm</code> builds your application by scanning your project directory for packages with specially-named files.</p> <ul> <li>Packages as URL segments: Each Python package maps to a URL segment. Nesting packages creates nested routes. For example, a package at <code>my_app/users/settings</code> (with <code>holm.App()</code> being called in a module in <code>my_app/</code>) corresponds to the <code>/users/settings</code> URL path.</li> <li>Dynamic routes: To create routes with path parameters (e.g., <code>/users/{id}</code>), name your package with underscores (<code>_id_</code>) or curly braces (<code>{id}</code>). The path parameter is then available as a standard FastAPI dependency (e.g., <code>def page(id: int): ...</code>).</li> <li>Special files mark application components: <code>holm</code> looks for specific filenames within your application package (in this example <code>my_app/</code>) to discover and wire up your application. The most important application components are discussed individually below.</li> <li>Private packages: To exclude a directory from the application discovery process, prefix its name with an underscore (e.g., <code>_components</code>). <code>holm</code> completely ignores these \"private\" packages and their subpackages, no matter what they contain.</li> </ul> <p>A key feature of <code>holm</code> is its deep integration with FastAPI's dependency injection system. Page, layout, action, and metadata functions are just FastAPI dependencies, allowing you to use FastAPI's dependency injection mechanism as you would in any other FastAPI dependency or path operation.</p> <p>It means if you have already used FastAPI, then you can transfer all your experience and existing codebase to <code>holm</code> without any adaptation.</p>"},{"location":"in-a-hurry/#pages-pagepy","title":"Pages (<code>page.py</code>)","text":"<p>The <code>page.py</code> module (and the <code>page</code> callable in it) defines the web page for the route segment of the package that contains it.</p> <ul> <li>The <code>page</code> variable must be a callable, which is treated as a FastAPI dependency.</li> <li>It handles <code>GET</code> requests for its package's URL path.</li> <li>It usually returns an <code>htmy.Component</code>, the children for the layout that wraps it, but the return value can be anything the owner layout accepts (if there is one).</li> </ul>"},{"location":"in-a-hurry/#layouts-layoutpy","title":"Layouts (<code>layout.py</code>)","text":"<p>The <code>layout.py</code> module defines a shared UI that wraps pages and other layouts in its subdirectories.</p> <p>The module must have a callable <code>layout</code> variable. Its first positional argument is provided by <code>holm</code> and it is the return value of the child component (usually a page or another layout) it wraps. Any subsequent arguments are resolved as standard FastAPI dependencies.</p> <p>Example:</p> <pre><code># my_app/page.py\nfrom htmy import ComponentType, html\n\ndef page() -&gt; ComponentType:\n    return html.div(\"Hello, world!\")\n</code></pre> <pre><code># my_app/layout.py\nfrom htmy import ComponentType, html\n\ndef layout(children: ComponentType) -&gt; ComponentType:\n    return html.html(\n        html.head(html.title(\"My App\")),\n        html.body(children),  # &lt;- The html.div page() returns\n    )\n</code></pre>"},{"location":"in-a-hurry/#page-metadata-pagepy","title":"Page metadata (<code>page.py</code>)","text":"<p>A <code>page.py</code> module can also have a <code>metadata</code> variable. This can be a simple dictionary or a FastAPI dependency that returns one. This mapping is made available to every <code>htmy.Component</code> in the HTML component tree through the <code>Metadata.from_context()</code> utility. A typical use case is to set page-specific information, like the title or meta tags, for layouts.</p> <p>Example:</p> <pre><code># my_app/page.py\nfrom htmy import ComponentType, html\n\ndef metadata() -&gt; dict[str, str]:\n    \"\"\"Metadata dependency for the page.\"\"\"\n    return {\"title\": \"My App\"}\n\ndef page() -&gt; ComponentType:\n    return html.div(\"Hello, world!\")\n</code></pre> <pre><code># my_app/layout.py\nfrom htmy import ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n@component\ndef head(default_title: str, context: Context) -&gt; ComponentType:\n    \"\"\"Custom head component that can access page metadata from the htmy context.\"\"\"\n    metadata = Metadata.from_context(context)  # &lt;- The mapping the `metadata` dependency of the page returned\n    title = metadata.get(\"title\", default_title)\n    return html.head(html.title(title))\n\ndef layout(children: ComponentType) -&gt; ComponentType:\n    return html.html(\n        head(\"My App\"),  # &lt;- Our custom head component\n        html.body(children),  # &lt;- The html.div page() returns\n    )\n</code></pre>"},{"location":"in-a-hurry/#actions-actionspy-or-pagepy","title":"Actions (<code>actions.py</code> or <code>page.py</code>)","text":"<p>An action is a function decorated with a <code>@action</code> decorator (<code>@action.get()</code>, <code>@action.post()</code>, etc.). As you probably expect, actions must be FastAPI dependencies as well, and they must normally return an <code>htmy.Component</code>. The default URL segment for an action is the decorated function's name.</p> <p>Actions can be defined in <code>actions.py</code> and <code>page.py</code> modules, and they are ideal for returning HTML fragments (partials) for client-side libraries like HTMX. The returned component is not wrapped in a layout by default, but you have the option to enable layout wrapping (<code>@action.get(use_layout=True)</code>) and even define action metadata (<code>@action.post(metadata={\"title\": \"Post\"})</code>).</p>"},{"location":"in-a-hurry/#form-submissions-pagepy","title":"Form submissions (<code>page.py</code>)","text":"<p>A <code>page.py</code> file can define a <code>handle_submit()</code> function (also a FastAPI dependency) alongside the <code>page()</code> function. Submit handlers behave exactly the same as pages, the only difference is their purpose and that they are HTTP <code>POST</code> routes, instead of <code>GET</code> routes.</p>"},{"location":"in-a-hurry/#custom-apis-apipy","title":"Custom APIs (<code>api.py</code>)","text":"<p>This is where you can create a custom <code>APIRouter</code> for the package, as an <code>api</code> variable which can be an <code>APIRouter</code> instance or a function that returns an <code>APIRouter</code>.</p> <p>It is most often used to configure the <code>APIRouter</code> of the package, for example by settings its dependencies, tags, or other options. You can also use it for defining JSON endpoints. Additionally, it can be used for serving HTML fragments (using the FastHX library), although actions provide a more convenient way for that.</p>"},{"location":"security/","title":"Security","text":"<p>While <code>holm</code> is built on top of the secure foundations of FastAPI and can take advantage of its entire ecosystem, it is still important to be mindful of common web vulnerabilities, especially Cross-Site Request Forgery (CSRF) and Cross-Site Scripting (XSS).</p>"},{"location":"security/#xss-prevention","title":"XSS prevention","text":"<p><code>holm</code> uses <code>htmy</code> under the hood, which performs XML/HTML escaping by default. You can find more information about this in the htmy documentation.</p>"},{"location":"security/#cross-site-request-forgery-csrf-prevention","title":"Cross-Site Request Forgery (CSRF) prevention","text":"<p><code>holm</code> takes a similar approach to CSRF prevention as Next.js, relying on web security fundamentals and modern browser security features:</p> <ul> <li>HTTP-only cookies, which are not accessible from JavaScript.</li> <li>Secure cookies, which are only sent over HTTPS.</li> <li><code>lax</code> or <code>strict</code> SameSite cookie policy.</li> <li>Cryptographically signed cookies to ensure data integrity and authenticity.</li> <li>Avoiding state-changing operations in HTTP GET requests.</li> </ul> <p>Together, these offer reasonable protection against CSRF attacks.</p> <p><code>holm</code> encourages these practices for example through:</p> <ul> <li>reliance on the FastAPI ecosystem;</li> <li>the <code>handle_submit()</code> functionality in <code>page.py</code> modules for <code>POST</code> requests;</li> <li>the custom <code>APIRouter</code> support in <code>api.py</code> modules.</li> </ul> <p>FastAPI middlewares that check the <code>Host</code>, <code>Origin</code>, and <code>Referer</code> headers can be used to add some additional security measures.</p> <p>For even more security, you should use CSRF tokens. The exact implementation depends on your application's architecture and frontend framework (if any). If you are using HTMX, you should follow their CSRF prevention recommendations.</p>"},{"location":"utilities/","title":"Utilities","text":""},{"location":"utilities/#without_layout","title":"<code>without_layout()</code>","text":"<p>You can use <code>without_layout()</code> in <code>page()</code>, <code>handle_submit()</code>, or <code>layout()</code> functions to opt their return value out of automatic layout wrapping.</p> <p>When you wrap the return value of a layout, page, or submit handler with <code>without_layout()</code>, <code>holm</code> will break the layout wrapping chain at that point and render the wrapped component directly, without passing it to further parent layouts. In other words, always the innermost <code>without_layout()</code> use -- the one closest to the page or submit handler -- will take effect.</p> <p>This is particularly useful for rendering partial HTML fragments from pages or submit handlers, a common requirement when working with libraries like HTMX. For example, you can serve the full HTML document on initial page load, but return only the updated portion of the page for subsequent HTMX requests.</p> <p>Here is an example of a <code>page</code> that serves a full HTML document for regular browser requests, but returns only a partial (the page content) for HTMX requests:</p> <pre><code>from fastapi import Request\nfrom htmy import Component, html\n\nfrom holm import without_layout\n\n\ndef page(request: Request) -&gt; Component:\n    content = html.h1(\"This is the page content\")\n\n    if request.headers.get(\"HX-Request\") == \"true\":\n        # It's an HTMX request, return only the page content\n        # without the layouts that wrap it.\n        return without_layout(content)\n\n    # It's a regular request, return props for the parent layout\n    # to render the full page.\n    return content\n</code></pre>"},{"location":"guides/actions-with-htmx/","title":"Actions with HTMX","text":"<p>This guide demonstrates how to enhance a basic <code>holm</code> application with <code>holm</code> actions and HTMX for dynamic, interactive web applications. We'll build upon the quick start guide to add server-rendered partial updates and seamless navigation using <code>holm</code>'s action system.</p> <p>Very basic familiarity with HTMX is helpful for this guide, but it can be followed even without it.</p> <p>Before you continue, make sure you have the basic application from the quick start guide working, as we will be expanding that application.</p> <p>We will cover:</p> <ul> <li>How to integrate HTMX for dynamic content updates.</li> <li>How to enhance navigation with the <code>hx-boost</code> HTMX attribute.</li> <li>How to create <code>holm</code> actions that return rendered HTML components, often called fragments or partials.</li> <li>How <code>holm</code> automatically generates API routes for actions.</li> </ul> <p>The entire source code of this application can be found in the examples/actions-with-htmx directory of the repository.</p>"},{"location":"guides/actions-with-htmx/#add-htmx-to-the-application","title":"Add HTMX to the application","text":"<p>Modify <code>layout.py</code> to include the HTMX script and enable <code>hx-boost</code> on the <code>nav</code> tag for enhanced navigation:</p> <pre><code>from htmy import Component, ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n\n@component\ndef layout(children: ComponentType, context: Context) -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    metadata = Metadata.from_context(context)\n\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                html.title(metadata.get(\"title\", \"My App\")),\n                html.meta(charset=\"utf-8\"),\n                html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n                html.link(  # Use PicoCSS to add some default styling.\n                    rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n                ),\n                html.script(src=\"https://unpkg.com/htmx.org@2.0.7\"),\n            ),\n            html.body(\n                html.header(\n                    html.nav(\n                        html.ul(\n                            html.li(html.a(\"Home\", href=\"/\")),\n                            html.li(html.a(\"About\", href=\"/about\")),\n                        ),\n                        hx_boost=\"true\",\n                    ),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 My App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre> <p>The changes in the layout are trivial, we simply:</p> <ul> <li>added the HTMX script tag to the <code>head</code> element of the webpage with <code>html.script(src=\"https://unpkg.com/htmx.org@2.0.7\")</code>;</li> <li>and set the <code>hx_boost</code> attribute on the <code>nav</code> element in the page <code>header</code> to boost our anchors.</li> </ul>"},{"location":"guides/actions-with-htmx/#create-actions","title":"Create actions","text":"<p>Next, we create our actions in an <code>actions.py</code> module. We will place it at the root of our project (next to <code>main.py</code>), because we want these actions to exist directly under the root <code>/</code> URL prefix.</p> <p>Note: <code>holm</code> applies file-system based routing to both pages and actions! If both an <code>actions.py</code> and a <code>page.py</code> exist in a directory (as often the case), <code>holm</code> combines their routes into a single <code>APIRouter</code> for that path.</p> <p>The action we create will be very simple, just a <code>welcome_message() -&gt; str</code> function that returns a welcome message in a randomly chosen language. The returned message is just a string (which happens to be a <code>htmy</code> <code>Component</code>), which <code>holm</code> automatically renders into an HTML response.</p> <p>The <code>welcome_message()</code> function is registered as an action using the <code>@action.get()</code> decorator. Since we don't pass a path to it and underscores (<code>_</code>) are replaced with hyphens (<code>-</code>) by default, it will be registered under <code>/welcome-message</code>.</p> <pre><code>import random\n\nfrom holm import action\n\n_welcome_message: list[str] = [\n    \"Welcome to My App! Powered By HTMX.\",\n    \"Bienvenido a My App! Powered By HTMX.\",\n    \"Bienvenue dans My App! Powered By HTMX.\",\n    \"Willkommen bei My App! Powered By HTMX.\",\n    \"Benvenuti nella mia app! Powered By HTMX.\",\n    \"\u00dcdv\u00f6z\u00f6lj\u00fck a My App-ban! Powered By HTMX.\",\n]\n\n\n@action.get()\ndef welcome_message() -&gt; str:\n    \"\"\"\n    Action that returns a welcome message component, which in this\n    case is a simple string.\n\n    No path was provided for the action decorator, by default it\n    creates the path from the decorator function's name, so the\n    path will be \"/welcome_message\" within the router that contains\n    the actions module.\n    \"\"\"\n    return random.choice(_welcome_message)  # noqa: S311\n</code></pre> <p>Important details:</p> <ul> <li>We use the <code>@action.get()</code> decorator to define a HTTP <code>GET</code> action. <code>holm</code> provides decorators for all standard HTTP methods (e.g., <code>@action.post()</code>, <code>@action.put()</code>, <code>@action.delete()</code>).</li> <li>Since no explicit path was provided to the <code>@action.get()</code> decorator, <code>holm</code> automatically infers the path from the function name, resulting in a <code>/welcome_message</code> endpoint.</li> <li>The return value (a plain string in this case) is automatically rendered by <code>holm</code> as an HTML response.</li> </ul>"},{"location":"guides/actions-with-htmx/#add-dynamic-behavior-to-the-home-page","title":"Add dynamic behavior to the home page","text":"<p>Finally we add dynamic content to the home page (<code>page.py</code> in the root directory) with a couple of simple HTMX attributes.</p> <p>On the <code>h1</code> element, which contains our welcome message, we set:</p> <ul> <li><code>hx_get</code> to use our newly created <code>/welcome_message</code> route (<code>welcome_message()</code> action) when HTMX is triggered.</li> <li><code>hx_trigger</code> to <code>every 2s</code> to make the page load a new welcome message from our action every 2 seconds.</li> </ul> <p>These two attributes together will replace the displayed welcome message every two seconds without reloading the entire page.</p> <p>For the sake of completeness, we also wrap the link at the bottom in a <code>div</code> and use <code>hx_boost</code> as before to enhance the navigation experience.</p> <pre><code>from htmy import Component, html\n\n# Static metadata for this page\nmetadata = {\"title\": \"Home | My App\"}\n\n\ndef page() -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return html.div(\n        html.h1(\n            \"Welcome to My App\",\n            hx_get=\"/welcome-message\",\n            hx_trigger=\"every 2s\",\n        ),\n        html.p(\"This is a minimal holm application demonstrating:\"),\n        html.ul(\n            html.li(\"File-system based routing\"),\n            html.li(\"Automatic layout composition\"),\n            html.li(\"Dynamic metadata\"),\n            html.li(\"Server-side rendering with htmy\"),\n            html.li(\"Actions with HTMX integration\"),\n        ),\n        html.div(\n            html.a(\"Learn more about us\", href=\"/about\"),\n            hx_boost=\"true\",  # Explicit hx-boost for this link\n        ),\n    )\n</code></pre> <p>That's it! You can now run your application using <code>uvicorn</code> or <code>fastapi-cli</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>You can now open your browser and navigate to <code>http://localhost:8000/</code> to see your application in action.</p> <p>If you followed every step correctly, then you will see the welcome message changing every two seconds on the home page.</p> <p>If you are curious to see how your action is called and how it responds, you can inspect requests on the Network tab of your browser's developer tools.</p>"},{"location":"guides/custom-applications/","title":"Custom applications","text":"<p>This guide demonstrates how to use a custom FastAPI application and <code>fasthx.htmy.HTMY</code> instance (HTML renderer) in your <code>holm</code> application. This allows you to leverage <code>holm</code>'s features while keeping full control over all underlying software components.</p> <p>In the vast majority of applications, using a default FastAPI application (one created by simply calling <code>FastAPI()</code>, as <code>holm</code> internally does) is not enough. Exception handlers, for example, can be registered with <code>holm</code>, but you often need to set up a lifespan method, register middlewares, or customize the OpenAPI documentation to your needs. As a matter of fact, you could even add routes to your application manually, just make sure their paths don't conflict with the routes <code>holm</code> registers for you automatically!</p> <p>When it comes to HTML rendering, you may occasionally need to configure the <code>fasthx.htmy.HTMY</code> instance with custom request processors, formatters, translation utilities, or global rendering context.</p> <p>Doing all of this in <code>holm</code> is very straightforward, all you need to do is:</p> <ol> <li>Create a <code>FastAPI</code> instance somewhere in your codebase and configure it, just like you would do in any FastAPI project.</li> <li>Create a <code>fasthx.htmy.HTMY</code> instance and configure it.</li> <li>Pass the created instances to the <code>holm.App()</code> function as <code>App(app=my_fastapi_instance, htmy=my_htmy_instance)</code>.</li> </ol> <p>The below example demonstrates these steps as simply as possible, through creating:</p> <ul> <li>a <code>FastAPI</code> instance with a <code>/health-check</code> route, and</li> <li>a <code>fasthx.htmy.HTMY</code> instance with a request processor.</li> </ul> <p>If you followed the quick-start-guide, then you can make these changes in the <code>main.py</code> file and immediately see the result in action.</p> <pre><code>from fastapi import FastAPI\nfrom fasthx.htmy import HTMY\n\nfrom holm import App\n\napp = FastAPI()\nhtmy = HTMY(\n    request_processors=[\n        # Add a request processor that inserts an \"is_htmx_request\" key\n        # into htmy rendering contexts, making this information available\n        # to htmy components as `context[\"is_htmx_request\"]`.\n        lambda request: {\"is_htmx_request\": request.headers.get(\"HX-Request\") == \"true\"}\n    ]\n)\n\n\n@app.get(\"/health-check\")\ndef health_check() -&gt; dict[str, str]:\n    \"\"\"Health check route registered directly on the FastAPI application.\"\"\"\n    return {\"status\": \"ok\"}\n\n\n# If holm.App() receives a FastAPI application instance, then it does its job and\n# returns the same object. This means you don't need to keep a separate reference\n# to the returned value, the already existing app variable is enough.\nApp(app=app, htmy=htmy)\n</code></pre> <p>That's it! If you start the application and open its OpenAPI documentation (<code>http://localhost:8000/docs</code>) in your browser, you will see the health check route you registered, in addition to all the routes <code>holm</code> discovered and registered automatically for you.</p> <p>Note: If you return a <code>htmy</code> component from a manually registered route, it will not be rendered as HTML automatically! The reason for this is simple: <code>holm</code> must not modify the behavior of user-defined application parts in any way. You can still do HTML rendering manually using the <code>htmy</code> instance in the same way as in <code>holm</code> API modules (see the Rendering APIs with HTMX guide).</p>"},{"location":"guides/error-handling/","title":"Error handling","text":"<p>This short guide demonstrates how to add error handling to your <code>holm</code> application. We'll build upon the quick start guide.</p> <p>Before you continue, make sure you have the basic application from the quick start guide working, as we will be expanding that application.</p> <p>As a reminder, you must write standard FastAPI error handlers (async functions with a <code>Request</code> and an <code>Exception</code> argument), as you would in any FastAPI application. The only difference is that error handlers can return <code>htmy.Component</code>s as well as FastAPI <code>Response</code> objects.</p> <p>For additional rules and recommendations on error handling, please read the corresponding section of the Application components guide.</p> <p>With all that said, let's set up error handling by adding the <code>error.py</code> or <code>errors.py</code> file to the root of our project (next to <code>main.py</code>).</p> <p>With the file in place, we need to:</p> <ul> <li>Create a standard FastAPI error handler that returns a component (<code>handle_404()</code> function).</li> <li>Create a <code>handlers</code> variable that maps HTTP error codes or exception types to the corresponding error handler.</li> </ul> <pre><code>from fastapi import Request\nfrom htmy import Component, html\n\nfrom holm import FastAPIErrorHandler\n\n\nasync def handle_404(request: Request, exc: Exception) -&gt; Component:\n    \"\"\"Handle 404 Not Found errors with a custom HTML page.\"\"\"\n    return html.div(\n        html.h1(\"Page not found\"),\n        html.p(\"The page you're looking for doesn't exist.\"),\n        html.a(\"Go back home\", href=\"/\")\n    )\n\n\nhandlers: dict[int | type[Exception], FastAPIErrorHandler] = {\n    404: handle_404,\n}\n\"\"\"Dictionary that maps HTTP error codes or exception types to error handlers.\"\"\"\n</code></pre> <p>That's it! <code>holm</code> automatically discovers your error handlers, registers them in the application, and renders components as usual.</p> <p>To test your work, you should run your application using <code>uvicorn</code> or <code>fastapi-cli</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>You can now open your browser and navigate to a non-existent page, such as <code>http://localhost:8000/does-not-exist</code> to see your custom HTTP 404 page in action.</p>"},{"location":"guides/forms/","title":"Forms","text":"<p>Let's explore how <code>holm</code> simplifies form handling by building a functional TODO application.</p> <p>We will cover:</p> <ul> <li>How to handle HTTP GET forms, by creating a global search bar with a form that uses a query parameter for filtering.</li> <li>How to handle HTTP POST forms, by implementing a form for creating new TODOs using <code>POST</code> requests, utilizing <code>holm</code>'s submit handler feature.</li> <li>Basic server-side form validation and error rendering.</li> <li>How to create reusable user interface components.</li> </ul> <p>The guide assumes you are familiar with the core concepts of <code>holm</code>, including layouts, pages, and submit handlers, and you are looking to put these features into practice.</p> <p>The entire source code of this application can be found in the examples/forms directory of the repository.</p> <p>Before you continue, ensure you have installed <code>holm</code> and either <code>uvicorn</code> or <code>fastapi-cli</code> (<code>pip install holm uvicorn</code> or <code>pip install holm fastapi-cli</code>)!</p>"},{"location":"guides/forms/#create-the-application-structure","title":"Create the application structure","text":"<p>First, create the following directory structure:</p> <pre><code>my_app/\n\u251c\u2500\u2500 main.py          # Application entry point\n\u251c\u2500\u2500 layout.py        # Root layout with global search bar\n\u251c\u2500\u2500 page.py          # Home page with a TODO creation form and a TODO list\n\u2514\u2500\u2500 todo_service.py  # Business logic for TODOs\n</code></pre>"},{"location":"guides/forms/#initialize-your-application","title":"Initialize your application","text":"<p>Create <code>main.py</code> first, our application's entry point.</p> <p>If you've read the quick start guide, then the application setup will already be familiar to you. If not, it's just two lines of code:</p> <pre><code>from holm import App\n\napp = App()\n</code></pre> <p>That's it. When you start the application, <code>holm</code> automatically discovers your application's structure and registers all routes for you.</p>"},{"location":"guides/forms/#data-model-and-services","title":"Data model and services","text":"<p>Let's continue by implementing the <code>todo_service.py</code> module. It acts as our data layer, and defines a <code>Todo</code> model and two services for listing and creating TODOs.</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass(frozen=True, slots=True)\nclass Todo:\n    \"\"\"A simple TODO item.\"\"\"\n\n    title: str\n    description: str\n\n\ntodos = [\n    Todo(\n        title=\"Home page\",\n        description=\"It should show the list of TODOs.\",\n    ),\n    Todo(\n        title=\"Add filtering\",\n        description=\"Add a form that filters the TODO list using substring search on the title.\",\n    ),\n    Todo(\n        title=\"Add a creation form\",\n        description=\"Add a form that submits a creation form with a POST request to a submit handler.\",\n    ),\n]\n\"\"\"The list of existing TODO items. This list acts as a database for the application.\"\"\"\n\n\ndef find_todos(query: str) -&gt; list[Todo]:\n    \"\"\"Returns a list of TODOs whose title contains the given query string.\"\"\"\n    query = query.lower()\n    return [todo for todo in todos if query in todo.title.lower()]\n\n\ndef create_todo(title: str, description: str) -&gt; Todo:\n    \"\"\"Creates a new TODO with the given title and description and stores it in the database.\"\"\"\n    todo = Todo(title=title, description=description)\n    todos.append(todo)\n    return todo\n</code></pre> <p>We now have all the basics in place. Let's move on to the interesting part, the user interface.</p>"},{"location":"guides/forms/#layout-with-a-global-search-form","title":"Layout with a global search form","text":"<p>The layout of this application will be a bit more complex than the one in the quick start guide:</p> <ul> <li>We will move the entire HTML <code>head</code> declaration into a separate component. This way the layout itself does not need to be a <code>htmy</code> component, because it does not need to access the <code>htmy</code> rendering context.</li> <li>The <code>header</code> component will contain a form that can be used for filtering on all pages.</li> </ul> <p>With that said, let's create <code>layout.py</code>, import everything we need, and start by implementing the mentioned custom HTML <code>head</code> component:</p> <pre><code>from fastapi import Request\nfrom htmy import Component, ComponentType, Context, XBool, component, html\n\nfrom holm import Metadata\n\n\n@component.context_only\ndef head(context: Context) -&gt; ComponentType:\n    \"\"\"\n    Helper component that returns the entire head element of the page.\n\n    It uses `Metadata` to correctly set the page title. This way we do not need\n    to access the `htmy` context in the layout itself, so that doesn't need to\n    be a `htmy` component, it can be a simple `holm` layout function with dependencies.\n    \"\"\"\n    metadata = Metadata.from_context(context)\n    return html.head(\n        html.title(metadata.get(\"title\", \"TODO App\")),\n        html.meta(charset=\"utf-8\"),\n        html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n        html.link(  # Use PicoCSS to add some default styling.\n            rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n        ),\n    )\n</code></pre> <p><code>head</code> is a simple, context-only <code>htmy</code> function component. The only <code>holm</code>-specific part in this bit of code is <code>Metadata</code>, which gives the component access to the metadata that's provided by the currently rendered page.</p> <p>Next we can add the search form:</p> <pre><code>def search_form(q: str, *, autofocus: bool) -&gt; ComponentType:\n    \"\"\"\n    Search form for the layout.\n\n    Arguments:\n        q: The current value of the `q` input.\n        autofocus: Whether the search input should be focused on page load.\n    \"\"\"\n    return html.form(\n        html.input_(\n            type=\"search\",\n            name=\"q\",  # The name of our filter query parameter.\n            value=q,  # Keep the value of the input field.\n            placeholder=\"Search...\",\n            # Focus automatically after GET requests. autofocus is a bool HTML\n            # attribute, so to disable it, we must either omit the attribute or\n            # use the XBool htmy utility.\n            autofocus=XBool.true if autofocus else XBool.false,\n        ),\n        html.button(\"Find\", type=\"submit\"),\n        role=\"search\",\n    )\n</code></pre> <p>The most important thing to note in the search form is that the input's <code>name</code> attribute is set to <code>\"q\"</code>. This is the name the browser will use to submit the value of our search input. As a consequence, our layout must have a <code>q: str</code> query parameter dependency in order to access the submitted value. Of course, pages that do filtering should also have the same dependency.</p> <p>Okay, we're done with all the complex parts! We can add the <code>layout</code> itself, which is quite simple: just a FastAPI dependency with the usual <code>children</code> property, a <code>request: Request</code> dependency that we use to decide whether to autofocus the search input, and the <code>q: str</code> query parameter dependency that we use to persist the search query between page loads.</p> <pre><code>def layout(children: ComponentType, request: Request, q: str = \"\") -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            # Use our head component.\n            head(),\n            html.body(\n                html.header(\n                    # Global search form, present in all pages, always submitted\n                    # with a GET request to the current URL. The input named \"q\"\n                    # contains the search query in the HTML, this is why the\n                    # layout has a matching q query parameter dependency.\n                    # Pages can use the same dependency for filtering.\n                    search_form(q, autofocus=request.method == \"GET\"),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 TODO App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre>"},{"location":"guides/forms/#home-page-with-a-todo-creation-form","title":"Home page with a TODO creation form","text":"<p>Create <code>page.py</code> for your home page. The page will:</p> <ul> <li>Show a form for creating new TODO items, demonstrating <code>holm</code>'s submit handler feature.</li> <li>Display the list of TODOs, always filtered by the search query (coming from the search form in our layout) if there is one.</li> <li>Do server-side form validation and error rendering, to forbid TODOs with empty or whitespace-only titles and descriptions.</li> <li>Show the fresh TODO list after successful creation, with an empty TODO creation form.</li> <li>Show the TODO list after failed creation, keeping the form data and marking invalid inputs (using the <code>aria-invalid</code> attribute).</li> </ul> <p>The description implies that the page looks essentially the same both on initial load and after TODO creation attempts, so it makes sense to extract the page content into a function (let's call it <code>page_content</code>) that we can use both in <code>page()</code> (our GET route) and in <code>handle_submit()</code> (our creation/POST route). Let's start with this component, which will actually be the bulk of our <code>page.py</code> module:</p> <pre><code>from typing import Annotated\n\nfrom fastapi import Form\nfrom htmy import ComponentType, Component, XBool, html\nfrom todo_service import create_todo, find_todos\n\n\ndef page_content(\n    q: str,\n    *,\n    title: str = \"\",\n    title_invalid: bool = False,\n    description: str = \"\",\n    description_invalid: bool = False,\n) -&gt; ComponentType:\n    \"\"\"\n    Returns the common page content for `page()` and `handle_submit()`.\n\n    Arguments:\n        q: The current query string for TODO list filtering.\n        title: The text to show in the title input.\n        title_invalid: Whether the title should be marked as invalid.\n        description: The text to show in the description input.\n        description_invalid: Whether the description should be marked as invalid.\n    \"\"\"\n    return html.div(\n        html.form(\n            # TODO creation form. It has a `title` and a `description` input field.\n            html.input_(\n                type=\"text\",\n                name=\"title\",\n                value=title,\n                autofocus=\"\",  # Try to focus this input by default.\n                # aria-invalid is a bool HTML attribute, so to disable it, we must\n                # either omit the attribute or use the XBool utility from htmy.\n                aria_invalid=XBool.true if title_invalid else XBool.false,\n            ),\n            html.input_(\n                type=\"text\",\n                name=\"description\",\n                value=description,\n                # aria-invalid is a bool HTML attribute, so to disable it, we must\n                # either omit the attribute or use the XBool utility from htmy.\n                aria_invalid=XBool.true if description_invalid else XBool.false,\n            ),\n            html.button(\"Create TODO\", type=\"submit\"),\n            # We don't need to set the form action, the default browser behavior is\n            # to submit forms to the current URL. We must set the method to POST\n            # though, to direct the request to our `handle_submit()` function,\n            # which is our POST request handler!\n            method=\"POST\",\n        ),\n        html.hr(),\n        html.div(\n            *(  # Create a PicoCSS Card for each TODO.\n                html.article(\n                    html.header(html.strong(todo.title)),\n                    html.p(todo.description),\n                )\n                for todo in find_todos(q)\n            )\n        ),\n    )\n</code></pre> <p>That's quite a few lines of code, but not too bad if you skip the in-code explanations.</p> <p>Let's also add the page metadata and our <code>page</code> function (our GET route):</p> <pre><code># Static metadata\nmetadata = {\"title\": \"Home | TODO App\"}\n\n\ndef page(q: str = \"\") -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return page_content(q)\n</code></pre> <p>As you can see, we use the same <code>q: str</code> query parameter as in our layout, so we can filter the TODO list.</p> <p><code>handle_submit</code> (our TODO creation/POST route) will be slightly more complex, because it needs to do basic input validation and TODO creation as well. Apart from this extra bit of logic, this function is also just a <code>page_content</code> call:</p> <pre><code>def handle_submit(\n    title: Annotated[str, Form()],\n    description: Annotated[str, Form()],\n    q: str = \"\",\n) -&gt; Component:\n    \"\"\"\n    Submit handler that expects a TODO title and description as form data.\n\n    It returns the page content the same way as `page()` does. The returned\n    component is wrapped in the page's layout the same way as it happens\n    with `page()`.\n    \"\"\"\n    title, description = title.strip(), description.strip()\n    title_invalid, description_invalid = title == \"\", description == \"\"\n    if not (title_invalid or description_invalid):\n        create_todo(title, description)  # Create the todo\n        # Reset the value of form fields before rendering the page.\n        title = description = \"\"\n\n    return page_content(\n        q,\n        title=title,\n        title_invalid=title_invalid,\n        description=description,\n        description_invalid=description_invalid,\n    )\n</code></pre> <p>That's it, the application is ready. This was a long guide, congratulations if you've made it all the way through!</p> <p>If you found this topic complex, don't worry, we covered a lot and you've already built up the necessary intuition to start building interactive applications with <code>holm</code> on your own!</p>"},{"location":"guides/forms/#run-your-application","title":"Run your application","text":"<p>You can now run your application using <code>uvicorn</code> or <code>fastapi-cli</code>, and see your work in action at <code>http://localhost:8000</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>Don't be surprised: the application uses an in-memory data layer (<code>todo_service.py</code> module), so it will be reset every time the application restarts.</p>"},{"location":"guides/path-parameters/","title":"Path parameters and dynamic routing","text":"<p>This guide demonstrates how to create pages with dynamic routes in a <code>holm</code> application. We'll build a simple application that lists users and shows a profile page for each user, with the user ID as a path parameter (dynamic URL segment).</p> <p>We will cover:</p> <ul> <li>How to create dynamic routes using <code>holm</code>'s file-system-based routing.</li> <li>How to access path parameters in your page and metadata functions.</li> <li>How to execute async code in pages, layouts, or metadata functions.</li> <li>How to generate dynamic metadata for pages with dynamic routes.</li> <li>How to use FastAPI dependencies to fetch data and share it between application components.</li> </ul> <p>The entire source code of this application can be found in the examples/path-parameters directory of the repository.</p> <p>This guide focuses on path parameters and dynamic routing, and has a lot in common with the Quick start guide. It is assumed you have the necessary dependencies installed, as described in the quick start guide.</p>"},{"location":"guides/path-parameters/#application-structure","title":"Application structure","text":"<p>Our application will have a home page, a page listing all users, and a dynamic page for individual user profiles. The corresponding file structure looks like this:</p> <pre><code>my_app/\n\u251c\u2500\u2500 layout.py\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 page.py\n\u2514\u2500\u2500 user/\n    \u251c\u2500\u2500 _id_/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 page.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 page.py\n    \u2514\u2500\u2500 service.py\n</code></pre> <p>The most interesting part is the <code>user/_id_/page.py</code> module. <code>holm</code> interprets the <code>_id_</code> package name as a path parameter named <code>id</code>, and creates the <code>/user/{id}</code> route for it. It lets you have <code>id: IdType</code> dependencies in page, metadata, and layout functions in this package (including its subpackages).</p>"},{"location":"guides/path-parameters/#application-initialization","title":"Application initialization","text":"<p>Let's start with <code>main.py</code>, our application's entry point. It's just two lines of code:</p> <pre><code>from holm import App\n\napp = App()\n</code></pre>"},{"location":"guides/path-parameters/#data-model-and-services","title":"Data model and services","text":"<p>Let's continue by implementing the <code>user/service.py</code> module. It acts as our data layer, and defines a <code>User</code> model and two <code>async</code> functions for fetching users. Think of it as a simple in-memory database with an <code>async</code> interface for demonstration.</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass(frozen=True, kw_only=True, slots=True)\nclass User:\n    \"\"\"User model.\"\"\"\n\n    id: int\n    name: str\n    email: str\n\n\nusers_by_id: dict[int, User] = {\n    i: User(id=i, name=f\"User {i}\", email=f\"user-{i}@holm.ccm\") for i in range(10)\n}\n\"\"\"Dictionary that maps user IDs to the corresponding user objects.\"\"\"\n\n\nasync def list_users() -&gt; list[User]:\n    \"\"\"\n    Lists all users.\n\n    The function is async to demonstrate how easily async tools, for example ORMs\n    can be used in `holm`.\n    \"\"\"\n    return list(users_by_id.values())\n\n\nasync def get_user(id: int) -&gt; User | None:\n    \"\"\"\n    Returns the user with the given ID, if the user exists.\n\n    The function is async to demonstrate how easily async tools, for example ORMs\n    can be used in `holm`.\n    \"\"\"\n    return users_by_id.get(id)\n</code></pre> <p>We now have everything in place to start working on the user interface!</p>"},{"location":"guides/path-parameters/#root-layout-and-home-page","title":"Root layout and home page","text":"<p>When it comes to the user interface, we should start with the application's layout and home page (<code>layout.py</code> and <code>page.py</code>, next to <code>main.py</code>).</p> <p>These are essentially the same as what we implemented in the Quick start guide, with minor changes in the layout's <code>nav</code> element and page content, so we won't go into the details here.</p> <p>Here is the layout (<code>layout.py</code>):</p> <pre><code>from htmy import Component, ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n\n@component\ndef layout(children: ComponentType, context: Context) -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    metadata = Metadata.from_context(context)\n    title = \"Admin App\"\n    # Let pages set only their subpage title, and add the application name automatically.\n    if subpage_title := metadata.get(\"title\"):\n        title = f\"{title} | {subpage_title}\"\n\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                html.title(title),\n                html.meta(charset=\"utf-8\"),\n                html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n                html.link(  # Use PicoCSS to add some default styling.\n                    rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n                ),\n            ),\n            html.body(\n                html.header(\n                    html.nav(\n                        html.ul(\n                            html.li(html.a(\"Home\", href=\"/\")),\n                            html.li(html.a(\"Users\", href=\"/user\")),\n                        )\n                    ),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 Admin App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre> <p>And here is the home page (<code>page.py</code>, next to <code>main.py</code>):</p> <pre><code>from htmy import Component, html\n\n# Static metadata for this page\nmetadata = {\"title\": \"Dashboard\"}\n\n\ndef page() -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return html.div(\n        html.h1(\"Welcome to Admin App\"),\n        html.p(\"This is a minimal holm application demonstrating:\"),\n        html.ul(\n            html.li(\"How to use path parameters, also known as dynamic routing\"),\n            html.li(\"File-system based routing with dynamic routes\"),\n        ),\n        html.a(\"Navigate to the User page to start exploring\", href=\"/user\"),\n    )\n</code></pre>"},{"location":"guides/path-parameters/#the-user-list-page","title":"The user list page","text":"<p>Next, we'll create the users page at the <code>/user</code> URL (<code>user/page.py</code>).</p> <p>This page uses the <code>list_users()</code> service to load the list of users, and displays them as a HTML list. Each list item contains an anchor tag that we can use to navigate to the user's profile page.</p> <pre><code>from htmy import Component, html\n\nfrom .service import list_users\n\nmetadata: dict[str, str] = {\"title\": \"Users\"}\n\n\nasync def page() -&gt; Component:\n    # Load users using an async service.\n    users = await list_users()\n    return html.div(\n        html.h1(\"Users:\"),\n        html.ul(\n            # Create list items with a link to the profile page for each user.\n            # Don't forget to use the spread operator! html.ul expects its\n            # children as positional arguments, not as a single list.\n            *(html.li(html.a(user.name, href=f\"/user/{user.id}\")) for user in users),\n        ),\n    )\n</code></pre>"},{"location":"guides/path-parameters/#user-profile-page","title":"User profile page","text":"<p>We have finally reached the essence of this guide: the user profile page. Don't expect any magic though.</p> <p>As explained at the start, <code>holm</code> automatically creates the <code>/user/{id}</code> URL for the page in the <code>user/_id_/page.py</code> module, so you can have <code>id: int</code> dependencies in page and metadata (even layout) functions. Or, as you will see and as you may expect if you are familiar with FastAPI, dependencies that depend on <code>id: int</code> in some way. The <code>id</code> argument is of course resolved from the <code>id</code> path parameter.</p> <p>With that said, let's create the user profile page:</p> <pre><code>from typing import Annotated\n\nfrom fastapi import Depends\nfrom htmy import ComponentType, html\n\nfrom ..service import User, get_user\n\n# The `get_user()` function expects an `id: int`. The argument's name and type\n# matches the `{id}` path parameter, which means we can use `get_user()` as\n# a FastAPI dependency without any additional work (FastAPI will resolve the\n# `id: int` argument correctly from the `{id}` path parameter)! Let's do this.\nDependsUser = Annotated[User | None, Depends(get_user)]\n\n\ndef metadata(id: int, user: DependsUser) -&gt; dict[str, str]:\n    \"\"\"\n    Metadata function that uses the `DependsUser` annotated FastAPI dependency\n    to get the user whose ID was submitted in the `{id}` path parameter (which\n    is the URL segment corresponding to the `_id_` package name.)\n\n    Just to show that the user was indeed loaded based on the submitted ID,\n    the metadata function also uses the `id: int` argument, that is resolved\n    by FastAPI from the `{id}` path parameter.\n    \"\"\"\n    user_title = \"Not Found\" if user is None else user.name\n    if user and user.id != id:\n        raise ValueError(\n            \"id and user.id should match, because both values originate \"\n            \"from the `{id}` path parameter the client submitted.\"\n        )\n    return {\n        \"title\": f\"User | {user_title}\",\n    }\n\n\nasync def page(user: DependsUser) -&gt; ComponentType:\n    \"\"\"\n    Page function that uses the `DependsUser` annotated FastAPI dependency\n    to get the user whose ID was submitted in the `{id}` path parameter.\n\n    FastAPI resolves each dependency once, meaning we're only loading the user\n    once, and we share it between application components through FastAPI's\n    dependency injection system.\n    \"\"\"\n    if user is None:\n        return html.div(\n            html.h1(\"The user does not exist\"),\n        )\n\n    return html.div(\n        html.strong(\"Name:\"),\n        html.span(user.name),\n        html.strong(\"ID:\"),\n        html.span(str(user.id)),\n        html.strong(\"Email:\"),\n        html.span(user.email),\n        style=\"display: grid; grid-template-columns: max-content 1fr; gap: 1rem;\",\n    )\n</code></pre> <p>Here is a summary of the key takeaways:</p> <ul> <li>Packages names of <code>_identifier_</code> format correspond to <code>{identifier}</code> URL segments.</li> <li><code>{identifier}</code> URL segments are FastAPI path parameters, and thus they enable dynamic routing.</li> <li>The <code>get_user(id: int)</code> service function can be used as a FastAPI dependency to conveniently get access to the requested user in page, metadata, and layout functions. This is also efficient, because FastAPI resolves each dependency only once.</li> </ul>"},{"location":"guides/path-parameters/#run-the-application","title":"Run the application","text":"<p>That's it! You can now run your application using <code>uvicorn</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with <code>fastapi-cli</code> if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>You can now open your browser, navigate to <code>http://localhost:8000/</code>, and start exploring your application in action.</p>"},{"location":"guides/quick-start-guide/","title":"Quick start guide","text":"<p>Let's create a minimal <code>holm</code> application with a layout, two pages, and dynamic page metadata!</p> <p>This example will get you up and running quickly by demonstrating the following core concepts:</p> <ul> <li>File-system routing: URLs automatically match your directory structure (<code>/about</code> maps to <code>about/page.py</code>).</li> <li>Automatic layout composition: The root layout automatically wraps all pages without manual configuration.</li> <li>Dynamic metadata: Pages can have static metadata (a mapping) or dynamic metadata (as a FastAPI dependency).</li> <li>FastAPI integration: Use standard FastAPI features (dependencies) in layouts, pages, and metadata functions.</li> <li>htmy components: Build your UI in typed Python with a JSX-like syntax.</li> </ul> <p>The entire source code of this application can be found in the examples/quick-start-guide directory of the repository.</p> <p>Before you continue, make sure you have installed <code>holm</code> and either <code>uvicorn</code> or <code>fastapi-cli</code> (<code>pip install holm uvicorn</code> or <code>pip install holm fastapi-cli</code>)!</p>"},{"location":"guides/quick-start-guide/#create-the-application-structure","title":"Create the application structure","text":"<p>First, create the following directory structure:</p> <pre><code>my_app/\n\u251c\u2500\u2500 main.py          # Application entry point\n\u251c\u2500\u2500 layout.py        # Root layout\n\u251c\u2500\u2500 page.py          # Home page\n\u2514\u2500\u2500 about/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 page.py      # About page\n</code></pre>"},{"location":"guides/quick-start-guide/#initialize-your-application","title":"Initialize your application","text":"<p>Create <code>main.py</code> to initialize your <code>holm</code> application:</p> <pre><code>from holm import App\n\napp = App()\n</code></pre> <p>This is all you need! The <code>App()</code> call will automatically discover and register all your layouts and pages based on the folder structure.</p>"},{"location":"guides/quick-start-guide/#create-a-root-layout","title":"Create a root layout","text":"<p>Create <code>layout.py</code> to define your application's root layout:</p> <pre><code>from htmy import Component, ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n\n@component\ndef layout(children: ComponentType, context: Context) -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    metadata = Metadata.from_context(context)\n\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                html.title(metadata.get(\"title\", \"My App\")),\n                html.meta(charset=\"utf-8\"),\n                html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n                html.link(  # Use PicoCSS to add some default styling.\n                    rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n                ),\n            ),\n            html.body(\n                html.header(\n                    html.nav(\n                        html.ul(\n                            html.li(html.a(\"Home\", href=\"/\")),\n                            html.li(html.a(\"About\", href=\"/about\")),\n                        )\n                    ),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 My App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre> <p>It is a usual, minimal HTML document, which uses PicoCSS to add some default styling.</p> <p>The layout itself is a <code>htmy</code> function component. This makes the <code>htmy</code> rendering context available in the layout (see the <code>context</code> argument). Page metadata is added to the <code>htmy</code> context by pages that define a <code>metadata</code> mapping or function. Being able to access the metadata (with <code>Metadata.from_context(context)</code>) is important, because this is how <code>htmy</code> components (in this case the layout) can get access to page-specific information, such as the desired page title.</p>"},{"location":"guides/quick-start-guide/#create-your-home-page","title":"Create your home page","text":"<p>Create <code>page.py</code> for your home page:</p> <pre><code>from htmy import Component, html\n\n# Static metadata for this page\nmetadata = {\"title\": \"Home | My App\"}\n\n\ndef page() -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return html.div(\n        html.h1(\"Welcome to My App\"),\n        html.p(\"This is a minimal holm application demonstrating:\"),\n        html.ul(\n            html.li(\"File-system based routing\"),\n            html.li(\"Automatic layout composition\"),\n            html.li(\"Dynamic metadata\"),\n            html.li(\"Server-side rendering with htmy\"),\n        ),\n        html.a(\"Learn more about us\", href=\"/about\"),\n    )\n</code></pre> <p>There are three interesting parts in the page implementation:</p> <ul> <li>How <code>metadata</code> is set by the page to provide the title for the layout.</li> <li>There is no manual page rendering: <code>page</code> is a simple FastAPI dependency, the value it returns is passed to its owner layout as is (see the layout's first argument), and <code>holm</code> takes care of rendering automatically.</li> <li>There is no explicit FastAPI route registration, <code>holm</code> does it automatically for you.</li> </ul>"},{"location":"guides/quick-start-guide/#create-an-about-page-with-dynamic-metadata","title":"Create an about page with dynamic metadata","text":"<p>Create <code>about/__init__.py</code> (empty file) and <code>about/page.py</code>:</p> <pre><code>from htmy import Component, html\n\n\nasync def metadata(featured: bool = False) -&gt; dict[str, str]:\n    \"\"\"\n    Dynamic metadata based on query parameters.\n\n    This function could be both sync or async. It's just a standard FastAPI dependency.\n    \"\"\"\n    title = \"Featured About\" if featured else \"About\"\n    return {\"title\": f\"{title} | My App\"}\n\n\nasync def page(featured: bool = False) -&gt; Component:\n    \"\"\"Async about page with dynamic content.\"\"\"\n    if featured:\n        return html.div(\n            html.h1(\"About Us \u2b50\"),\n            html.p(\"This is our featured about page!\"),\n            html.p(\"You're viewing the special featured version.\"),\n            html.a(\"Regular version\", href=\"/about\"),\n        )\n\n    return html.div(\n        html.h1(\"About Us\"),\n        html.p(\"We're building amazing web applications with holm.\"),\n        html.p(\"Our framework combines the power of FastAPI with server-side rendering.\"),\n        html.a(\"Featured version\", href=\"/about?featured=true\"),\n    )\n</code></pre> <p>The about page differs from the home page in two important aspects.</p> <p>First is the <code>metadata</code>, which is a function in this case, or more precisely a FastAPI dependency, that returns the metadata mapping for the page. Being a FastAPI dependency means that if a <code>featured</code> query parameter is provided, it will be automatically passed to this function by FastAPI. You could of course use any other FastAPI dependency here.</p> <p>Second is the <code>page</code> function, which also has a <code>featured</code> query parameter. As you might have guessed, just like <code>metadata</code>, <code>page</code> is also a FastAPI dependency. In this case these two dependencies have the same arguments, but it is not necessary to be like this! <code>page</code> and <code>metadata</code> could both have totally different dependencies, <code>holm</code> and FastAPI takes care of their correct handling for you!</p> <p>That's it! You now have a working application. From here, you can add more pages, create nested layouts, add API endpoints, and explore the full power of FastAPI, <code>htmy</code>, and FastHX.</p>"},{"location":"guides/quick-start-guide/#run-your-application","title":"Run your application","text":"<p>You can now run your application using <code>uvicorn</code> or <code>fastapi-cli</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>Visit these URLs to see your application in action:</p> <ul> <li><code>http://localhost:8000</code>: Home page</li> <li><code>http://localhost:8000/about</code>: About page</li> <li><code>http://localhost:8000/about?featured=true</code>: About page with dynamic content</li> </ul>"},{"location":"guides/rendering-apis-with-htmx/","title":"Rendering APIs with HTMX","text":"<p>This guide demonstrates how to enhance a basic <code>holm</code> application with a rendering API and HTMX for dynamic, interactive web applications. We'll build upon the quick start guide to add server-rendered partial updates and seamless navigation.</p> <p>Very basic familiarity with HTMX is helpful for this guide, but it can be followed even without it.</p> <p>Before you continue, make sure you have the basic application from the quick start guide working, as we will be expanding that application.</p> <p>We will cover:</p> <ul> <li>How to integrate HTMX for dynamic content updates.</li> <li>How to enhance navigation with the <code>hx-boost</code> HTMX attribute.</li> <li>How to create API endpoints that return rendered HTML components, often called fragments or partials.</li> <li>How to use fasthx for seamless server-side rendering of htmy components.</li> </ul> <p>The entire source code of this application can be found in the examples/rendering-apis-with-htmx directory of the repository.</p>"},{"location":"guides/rendering-apis-with-htmx/#add-htmx-to-the-application","title":"Add HTMX to the application","text":"<p>Modify <code>layout.py</code> to include the HTMX script and enable <code>hx-boost</code> on the <code>nav</code> tag for enhanced navigation:</p> <pre><code>from htmy import Component, ComponentType, Context, component, html\n\nfrom holm import Metadata\n\n\n@component\ndef layout(children: ComponentType, context: Context) -&gt; Component:\n    \"\"\"Root layout wrapping all pages.\"\"\"\n    metadata = Metadata.from_context(context)\n\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                html.title(metadata.get(\"title\", \"My App\")),\n                html.meta(charset=\"utf-8\"),\n                html.meta(name=\"viewport\", content=\"width=device-width, initial-scale=1\"),\n                html.link(  # Use PicoCSS to add some default styling.\n                    rel=\"stylesheet\", href=\"https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css\"\n                ),\n                html.script(src=\"https://unpkg.com/htmx.org@2.0.7\"),\n            ),\n            html.body(\n                html.header(\n                    html.nav(\n                        html.ul(\n                            html.li(html.a(\"Home\", href=\"/\")),\n                            html.li(html.a(\"About\", href=\"/about\")),\n                        ),\n                        hx_boost=\"true\",\n                    ),\n                    class_=\"container\",\n                ),\n                html.main(children, class_=\"container\"),\n                html.footer(html.p(\"\u00a9 2025 My App\"), class_=\"container\"),\n                class_=\"container-fluid\",\n            ),\n        ),\n    )\n</code></pre> <p>The changes in the layout are trivial, we simply:</p> <ul> <li>added the HTMX script tag to the <code>head</code> element of the webpage with <code>html.script(src=\"https://unpkg.com/htmx.org@2.0.7\")</code>;</li> <li>and set the <code>hx_boost</code> attribute on the <code>nav</code> element in the page <code>header</code> to boost our anchors.</li> </ul>"},{"location":"guides/rendering-apis-with-htmx/#create-the-rendering-api","title":"Create the rendering API","text":"<p>Next we create our rendering API in an <code>api.py</code> module. We will place it at the root of our project (next to <code>main.py</code>), because we want this API to exist directly under the root <code>/</code> URL prefix.</p> <p>Note: <code>holm</code> applies file-system based routing to both pages and APIs! If both an API (<code>api.py</code>) and a page (<code>page.py</code>) exists in a directory, <code>holm</code> combines their routes into a single <code>APIRouter</code> for that path.</p> <p>The API we create will be very simple, it will have a single <code>/welcome-message</code> route that returns a welcome message in a randomly chosen language. The returned message is just a string (which happens to be a <code>htmy</code> <code>Component</code>), so all we need to do is decorate the path operation function with <code>@htmy.hx()</code>. You can learn more about using <code>fasthx.htmy.HTMY</code> here.</p> <pre><code>import random\n\nfrom fastapi import APIRouter\nfrom fasthx.htmy import HTMY\n\n_welcome_message: list[str] = [\n    \"Welcome to My App! Powered By HTMX.\",\n    \"Bienvenido a My App! Powered By HTMX.\",\n    \"Bienvenue dans My App! Powered By HTMX.\",\n    \"Willkommen bei My App! Powered By HTMX.\",\n    \"Benvenuti nella mia app! Powered By HTMX.\",\n    \"\u00dcdv\u00f6z\u00f6lj\u00fck a My App-ban! Powered By HTMX.\",\n]\n\n\ndef api(htmy: HTMY) -&gt; APIRouter:\n    \"\"\"Rendering API factories need a `htmy: fasthx.htmy.HTMY` argument.\"\"\"\n    api = APIRouter()\n\n    @api.get(\"/welcome-message\")\n    @htmy.hx()  # type: ignore[arg-type]\n    async def get_welcome_message() -&gt; str:\n        return random.choice(_welcome_message)  # noqa: S311\n\n    return api\n</code></pre> <p>Important details:</p> <ul> <li>The <code>htmy.hx()</code> decorator is responsible for rendering the route's return value. It must be wrapped by the <code>@api</code> decorator.</li> <li>Within the <code>api()</code> function, everything is standard FastAPI and FastHX functionality.</li> <li>While this example only adds a rendering route, you can freely mix rendering and JSON APIs.</li> </ul>"},{"location":"guides/rendering-apis-with-htmx/#add-dynamic-behavior-to-the-home-page","title":"Add dynamic behavior to the home page","text":"<p>Finally we add dynamic content to the home page (<code>page.py</code> in the root directory) with a couple of simple HTMX attributes.</p> <p>On the <code>h1</code> element, which contains our welcome message, we set:</p> <ul> <li><code>hx_get</code> to the use our newly created <code>/welcome-message</code> route when HTMX is triggered.</li> <li><code>hx_trigger</code> to <code>every 2s</code> to make the page load a new welcome message from our API every 2 seconds.</li> </ul> <p>These two attributes together will replace the displayed welcome message every two seconds without reloading the entire page.</p> <p>For the sake of completeness, we also wrap the link at the bottom in a <code>div</code> and use <code>hx_boost</code> as before to enhance the navigation experience.</p> <pre><code>from htmy import Component, html\n\n# Static metadata for this page\nmetadata = {\"title\": \"Home | My App\"}\n\n\ndef page() -&gt; Component:\n    \"\"\"Home page content.\"\"\"\n    return html.div(\n        html.h1(\n            \"Welcome to My App\",\n            hx_get=\"/welcome-message\",\n            hx_trigger=\"every 2s\",\n        ),\n        html.p(\"This is a minimal holm application demonstrating:\"),\n        html.ul(\n            html.li(\"File-system based routing\"),\n            html.li(\"Automatic layout composition\"),\n            html.li(\"Dynamic metadata\"),\n            html.li(\"Server-side rendering with htmy\"),\n            html.li(\"Custom API with HTML rendering support\"),\n            html.li(\"HTMX integration\"),\n        ),\n        html.div(\n            html.a(\"Learn more about us\", href=\"/about\"),\n            hx_boost=\"true\",  # Explicit hx-boost for this link\n        ),\n    )\n</code></pre> <p>That's it! You can now run your application using <code>uvicorn</code> or <code>fastapi-cli</code>:</p> <pre><code>uvicorn main:app --reload\n</code></pre> <p>Or with the FastAPI CLI if installed:</p> <pre><code>fastapi dev main.py\n</code></pre> <p>You can now open your browser and navigate to <code>http://localhost:8000/</code> to see your application in action.</p> <p>If you followed every step correctly, then you will see the welcome message changing every two seconds on the home page.</p> <p>If you are curious to see how your API is called and how it responds, you can inspect requests on the Network tab of your browser's developer tools.</p>"}]}